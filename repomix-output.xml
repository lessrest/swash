This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: vterm-service/libvterm/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
vterm-service/
  fcft_wrapper.c
  fcft_wrapper.h
  flake.lock
  flake.nix
  meson.build
  vterm-service.cpp
.envrc
.gitignore
.python-version
claude.py
flake.lock
flake.nix
main.py
pyproject.toml
README.md
swash
swash_identity.py
swash_journal.py
swash-mcp
swash-web.py
swash.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "outputStyle": "Explanatory"
}
</file>

<file path="vterm-service/flake.lock">
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1764667669,
        "narHash": "sha256-7WUCZfmqLAssbDqwg9cUDAXrSoXN79eEEq17qhTNM/Y=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "418468ac9527e799809c900eda37cbff999199b6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path=".envrc">
use flake
source .env
</file>

<file path=".python-version">
3.13
</file>

<file path="claude.py">
#!/usr/bin/env python3
"""
claude.py - Claude LLM API demo with tool calling, journald + git storage

Messages are stored as RDF/Turtle in git commits: ~/.local/share/claude/messages.git
Each session is a ref: refs/sessions/<SESSION_ID>

Usage:
    nix run .#claude -- "Your prompt here"
    nix run .#claude -- --resume SESSION_ID "Continue the conversation"
    nix run .#claude -- --list                 # List available sessions

View conversation history:
    git -C ~/.local/share/claude/messages.git log refs/sessions/<SESSION_ID>
    git -C ~/.local/share/claude/messages.git show HEAD:msg/<id>.ttl
"""

import argparse
import asyncio
import json
import os
import sys
import time
import uuid
from abc import abstractmethod
from datetime import datetime
from pathlib import Path
from typing import Protocol, runtime_checkable

import pygit2
from anthropic import AsyncAnthropic, beta_async_tool
from rdflib import Graph, Literal, Namespace
from rdflib.namespace import RDF, XSD
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from systemd import journal

console = Console()

# =============================================================================
# RDF Namespaces
# =============================================================================

AS = Namespace("https://www.w3.org/ns/activitystreams#")
CLAUDE = Namespace("https://anthropic.com/ns/claude#")


# =============================================================================
# SessionGraph - RDF graph as the single source of truth
# =============================================================================


class SessionGraph:
    """
    RDF graph as the primary data structure for a conversation session.

    All operations add facts (triples) to the graph. The nested dict/list
    representation for the Anthropic API is built on-demand by querying the graph.
    """

    def __init__(self, session_id: str):
        self.session_id = session_id
        self.graph = Graph()
        self.graph.bind("as", AS)
        self.graph.bind("claude", CLAUDE)
        self._last_message_id: str | None = None

    @property
    def last_message_id(self) -> str | None:
        return self._last_message_id

    # -------------------------------------------------------------------------
    # Graph primitives - thin wrappers for common operations
    # -------------------------------------------------------------------------

    def _add(self, *triples):
        """Add multiple triples to the graph."""
        for triple in triples:
            self.graph.add(triple)

    def _str(self, subject, predicate) -> str:
        """Get a string value from the graph, defaulting to empty string."""
        return str(self.graph.value(subject, predicate) or "")

    def _has_type(self, subject, rdf_type) -> bool:
        """Check if subject has the given RDF type."""
        return (subject, RDF.type, rdf_type) in self.graph

    def _of_type(self, rdf_type):
        """Iterate subjects that have the given RDF type."""
        return self.graph.subjects(RDF.type, rdf_type)

    # URI builders - consistent namespace URIs
    def _msg(self, msg_id: str): return CLAUDE[f"message/{msg_id}"]
    def _actor(self, name: str): return CLAUDE[f"actor/{name}"]
    def _session(self): return CLAUDE[f"session/{self.session_id}"]
    def _tool(self, tool_id: str): return CLAUDE[f"tool_use/{tool_id}"]
    def _result(self, tool_id: str): return CLAUDE[f"tool_result/{tool_id}"]

    # -------------------------------------------------------------------------
    # Fact-adding methods - these mutate the graph
    # -------------------------------------------------------------------------

    def _add_message(self, message_id: str, actor: str, content: str | None = None) -> None:
        """Add a message node with common properties."""
        msg = self._msg(message_id)
        self._add(
            (msg, RDF.type, AS.Note),
            (msg, AS.id, Literal(message_id)),
            (msg, AS.published, Literal(datetime.now().isoformat(), datatype=XSD.dateTime)),
            (msg, AS.attributedTo, self._actor(actor)),
            (msg, CLAUDE.session, self._session()),
        )
        if content:
            self._add((msg, AS.content, Literal(content)))
        if self._last_message_id:
            self._add((msg, AS.inReplyTo, self._msg(self._last_message_id)))
        self._last_message_id = message_id

    def add_user_message(self, message_id: str, content: str) -> None:
        """Add a user message to the graph."""
        self._add_message(message_id, "user", content)

    def add_assistant_message(self, message_id: str) -> None:
        """Add an assistant message node (text content added separately)."""
        self._add_message(message_id, "claude")

    def set_message_content(self, message_id: str, content: str) -> None:
        """Set the text content of a message."""
        self._add((self._msg(message_id), AS.content, Literal(content)))

    def add_tool_use(self, message_id: str, tool_use_id: str, tool_name: str, input_data: dict) -> None:
        """Add a tool use attached to an assistant message."""
        msg, tool = self._msg(message_id), self._tool(tool_use_id)
        self._add(
            (tool, RDF.type, CLAUDE.ToolUse),
            (tool, AS.id, Literal(tool_use_id)),
            (tool, CLAUDE.tool, Literal(tool_name)),
            (tool, CLAUDE.input, Literal(json.dumps(input_data))),
            (msg, AS.attachment, tool),
            (tool, AS.context, msg),
        )

    def add_tool_result(self, tool_use_id: str, content: str) -> None:
        """Add a tool result linked to its tool use."""
        tool, result = self._tool(tool_use_id), self._result(tool_use_id)
        self._add(
            (result, RDF.type, CLAUDE.ToolResult),
            (result, AS.content, Literal(content)),
            (result, AS.inReplyTo, tool),
        )

    # -------------------------------------------------------------------------
    # Graph query methods - each returns a value from the graph
    # -------------------------------------------------------------------------

    def _get_message_role(self, msg_uri) -> str:
        """Returns 'user' or 'assistant' based on attributedTo."""
        return "user" if "actor/user" in self._str(msg_uri, AS.attributedTo) else "assistant"

    def _get_session_messages(self) -> list[tuple]:
        """Returns [(msg_uri, published, role), ...] sorted by timestamp."""
        messages = [
            (msg, self._str(msg, AS.published), self._get_message_role(msg))
            for msg in self._of_type(AS.Note)
            if self.graph.value(msg, CLAUDE.session) == self._session()
        ]
        return sorted(messages, key=lambda x: x[1])

    def _get_message_content(self, msg_uri) -> str:
        """Returns the text content of a message."""
        return self._str(msg_uri, AS.content)

    def _parse_json(self, s: str, default=None):
        """Parse JSON string, returning default on failure."""
        try:
            return json.loads(s)
        except json.JSONDecodeError:
            return default if default is not None else {}

    def _get_tool_use_block(self, tool_uri) -> dict:
        """Returns an API tool_use block from a tool URI."""
        return {
            "type": "tool_use",
            "id": self._str(tool_uri, AS.id),
            "name": self._str(tool_uri, CLAUDE.tool),
            "input": self._parse_json(self._str(tool_uri, CLAUDE.input) or "{}"),
        }

    def _get_tool_result_block(self, tool_uri, tool_id: str) -> dict | None:
        """Returns an API tool_result block if a result exists for this tool use."""
        result = next(
            (uri for uri in self.graph.subjects(AS.inReplyTo, tool_uri)
             if self._has_type(uri, CLAUDE.ToolResult)),
            None
        )
        return {"type": "tool_result", "tool_use_id": tool_id, "content": self._str(result, AS.content)} if result else None

    def _get_message_tool_uses(self, msg_uri) -> list:
        """Returns all tool_use URIs attached to a message."""
        return [
            tool for tool in self.graph.objects(msg_uri, AS.attachment)
            if self._has_type(tool, CLAUDE.ToolUse)
        ]

    # -------------------------------------------------------------------------
    # Block generators - yield content blocks within messages
    # -------------------------------------------------------------------------

    def _iter_text_block(self, content: str):
        """Yields a text block if content is non-empty."""
        if content:
            yield {"type": "text", "text": content}

    def _iter_tool_use_blocks(self, msg_uri):
        """Yields tool_use blocks for all tools attached to a message."""
        for tool_uri in self._get_message_tool_uses(msg_uri):
            yield self._get_tool_use_block(tool_uri)

    def _iter_tool_result_blocks(self, msg_uri):
        """Yields tool_result blocks for all tool results in a message."""
        for tool_uri in self._get_message_tool_uses(msg_uri):
            if result := self._get_tool_result_block(tool_uri, self._str(tool_uri, AS.id)):
                yield result

    # -------------------------------------------------------------------------
    # Message generators - yield complete API messages
    # -------------------------------------------------------------------------

    def _iter_user_message(self, msg_uri):
        """Yields a user API message if content exists."""
        if content := self._get_message_content(msg_uri):
            yield {"role": "user", "content": content}

    def _iter_assistant_messages(self, msg_uri):
        """Yields API messages for an assistant turn (1-2 messages)."""
        content = self._get_message_content(msg_uri)
        tool_use_blocks = list(self._iter_tool_use_blocks(msg_uri))

        content_blocks = list(self._iter_text_block(content)) + tool_use_blocks
        yield {"role": "assistant", "content": content_blocks}

        if tool_result_blocks := list(self._iter_tool_result_blocks(msg_uri)):
            yield {"role": "user", "content": tool_result_blocks}

    def _iter_message(self, msg_uri, role: str):
        """Yields API messages for a single graph message."""
        if role == "user":
            yield from self._iter_user_message(msg_uri)
        else:
            yield from self._iter_assistant_messages(msg_uri)

    def iter_api_messages(self):
        """Yields API messages by querying the graph."""
        for msg_uri, _, role in self._get_session_messages():
            yield from self._iter_message(msg_uri, role)

    def build_api_messages(self) -> list[dict]:
        """Query the graph and build the messages list for the Anthropic API."""
        return list(self.iter_api_messages())

    # -------------------------------------------------------------------------
    # Serialization
    # -------------------------------------------------------------------------

    def serialize(self, format: str = "turtle") -> str:
        """Serialize the graph to a string."""
        return self.graph.serialize(format=format)

    def parse(self, data: str, format: str = "turtle") -> None:
        """Parse serialized data into the graph."""
        self.graph.parse(data=data, format=format)
        self._restore_last_message_id()

    def _restore_last_message_id(self) -> None:
        """Find the most recent message ID from the graph."""
        if messages := self._get_session_messages():
            self._last_message_id = self._str(messages[-1][0], AS.id)


@runtime_checkable
class EventLogger(Protocol):
    """Protocol for event logging backends."""

    @abstractmethod
    def log(
        self,
        event_type: str,
        data: dict,
        message_id: str | None = None,
        message: str | None = None,
    ) -> None:
        """Log an event with optional message context."""
        ...


# =============================================================================
# Git Storage - Simple persistence for SessionGraph
# =============================================================================

MESSAGES_REPO_PATH = Path.home() / ".local/share/claude/messages.git"


def get_messages_repo() -> pygit2.Repository:
    """Get or create the messages git repository."""
    if not MESSAGES_REPO_PATH.exists():
        MESSAGES_REPO_PATH.parent.mkdir(parents=True, exist_ok=True)
        return pygit2.init_repository(str(MESSAGES_REPO_PATH), bare=True)
    return pygit2.Repository(str(MESSAGES_REPO_PATH))


class GitSessionStore:
    """
    Simple git-backed persistence for SessionGraph.

    The entire session graph is stored as a single turtle file.
    Each save creates a new commit; sessions are refs/sessions/<id>.
    """

    def __init__(self):
        self.repo = get_messages_repo()

    def list_sessions(self) -> list[tuple[str, str, str]]:
        """List all sessions: (session_id, timestamp, summary)."""
        sessions = []
        for ref in self.repo.references:
            if ref.startswith("refs/sessions/"):
                session_id = ref.removeprefix("refs/sessions/")
                try:
                    commit = self.repo.revparse_single(ref)
                    summary = commit.message.split("\n")[0] if commit.message else ""
                    timestamp = datetime.fromtimestamp(commit.commit_time).strftime("%Y-%m-%d %H:%M")
                    sessions.append((session_id, timestamp, summary))
                except Exception:
                    sessions.append((session_id, "?", "?"))
        return sorted(sessions, key=lambda x: x[1], reverse=True)

    def load(self, session_id: str) -> SessionGraph | None:
        """Load a SessionGraph from git, or None if not found."""
        ref_name = f"refs/sessions/{session_id}"
        try:
            commit = self.repo.revparse_single(ref_name)
        except KeyError:
            return None

        tree = commit.tree
        if "session.ttl" not in tree:
            # Try legacy format with msg/ directory
            return self._load_legacy(session_id, tree)

        blob = self.repo.get(tree["session.ttl"].id)
        graph = SessionGraph(session_id)
        graph.parse(blob.data.decode(), format="turtle")
        return graph

    def save(self, graph: SessionGraph, commit_message: str) -> pygit2.Oid:
        """Save the SessionGraph to git, returning the commit ID."""
        session_id = graph.session_id
        ref_name = f"refs/sessions/{session_id}"

        # Serialize graph to turtle
        ttl = graph.serialize(format="turtle")
        blob_id = self.repo.create_blob(ttl.encode())

        # Build tree with single session.ttl file
        tree_builder = self.repo.TreeBuilder()
        tree_builder.insert("session.ttl", blob_id, pygit2.GIT_FILEMODE_BLOB)
        tree_id = tree_builder.write()

        # Get parent commit if exists
        parents = []
        try:
            parent = self.repo.revparse_single(ref_name)
            parents = [parent.id]
        except KeyError:
            pass

        # Create commit
        sig = pygit2.Signature("Claude Session", "session@claude.local")
        summary = commit_message[:72] + "..." if len(commit_message) > 72 else commit_message
        full_message = f"{summary}\n\nSession: {session_id}"

        commit_id = self.repo.create_commit(None, sig, sig, full_message, tree_id, parents)

        # Update session ref
        try:
            self.repo.references.create(ref_name, commit_id, force=True)
        except Exception:
            self.repo.references.get(ref_name).set_target(commit_id)

        return commit_id


# =============================================================================
# Logging
# =============================================================================


class JournaldLogger:
    """
    Journald-backed event logger implementing the EventLogger protocol.

    Logs events to systemd journal with structured fields for querying.
    """

    def __init__(self, session_id: str):
        """
        Initialize the logger for a session.

        Args:
            session_id: Session identifier included in all log entries
        """
        self.session_id = session_id

    def log(
        self,
        event_type: str,
        data: dict,
        message_id: str | None = None,
        message: str | None = None,
    ) -> None:
        """Log an event to journald with structured fields."""
        fields = {
            "CLAUDE_SESSION": self.session_id,
            "CLAUDE_EVENT": event_type,
            "CLAUDE_TIMESTAMP": str(time.time()),
            "CLAUDE_DATA": json.dumps(data),
        }
        if message_id:
            fields["CLAUDE_MESSAGE_ID"] = message_id
        if message is None:
            message = f"[{event_type}] {json.dumps(data, ensure_ascii=False)[:200]}"
        journal.send(message, **fields)


def make_user_message_id() -> str:
    """Generate a unique message ID for user messages."""
    return f"msg_user_{uuid.uuid4().hex[:24]}"


@beta_async_tool
async def calculator(expression: str) -> str:
    """Evaluate a mathematical expression.

    Args:
        expression (str): The mathematical expression to evaluate, e.g. '2 + 2' or '(10 * 5) / 2'. Supports basic arithmetic (+, -, *, /), exponentiation (**), and parentheses.

    Returns:
        str: The result of the calculation.
    """
    allowed = set("0123456789+-*/(). ")
    if not all(c in allowed for c in expression):
        return "Error: Invalid characters in expression"
    try:
        result = eval(expression, {"__builtins__": {}}, {})
        return str(result)
    except Exception as e:
        return f"Error: {e}"


@beta_async_tool
async def get_current_time() -> str:
    """Get the current date and time.

    Returns:
        str: The current date and time in YYYY-MM-DD HH:MM:SS format.
    """
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def error(msg: str):
    console.print(f"[red]error:[/red] {msg}")
    sys.exit(1)


async def main():
    parser = argparse.ArgumentParser(description="Claude CLI with git-backed message history")
    parser.add_argument("prompt", nargs="*", help="The prompt to send")
    parser.add_argument("--resume", "-r", metavar="SESSION", help="Resume from a previous session")
    parser.add_argument("--list", "-l", action="store_true", help="List available sessions")
    args = parser.parse_args()

    # Git storage for persistence
    git_store = GitSessionStore()

    # Handle --list command
    if args.list:
        sessions = git_store.list_sessions()
        if not sessions:
            console.print("[dim]No sessions found[/dim]")
            return

        table = Table(title="Sessions")
        table.add_column("Session ID", style="cyan")
        table.add_column("Last Updated", style="green")
        table.add_column("Last Message", style="white")
        for sid, ts, summary in sessions[:20]:
            table.add_row(sid, ts, summary[:60])
        console.print(table)
        return

    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if not api_key:
        error("ANTHROPIC_API_KEY environment variable not set")

    prompt = " ".join(args.prompt) if args.prompt else "What is 123 * 456? Also, what time is it?"

    # Load or create SessionGraph - the single source of truth
    if args.resume:
        session_id = args.resume
        graph = git_store.load(session_id)
        if graph:
            console.print(f"[dim]Resuming session:[/dim] {session_id}")
            msg_count = len(graph._get_session_messages())
            console.print(f"[dim]Loaded {msg_count} messages from history[/dim]")
        else:
            console.print(f"[yellow]Warning: No messages found in session {args.resume}[/yellow]")
            session_id = uuid.uuid4().hex[:12].upper()
            graph = SessionGraph(session_id)
    else:
        session_id = uuid.uuid4().hex[:12].upper()
        graph = SessionGraph(session_id)

    # Create logger for this session
    logger = JournaldLogger(session_id)

    console.print(f"[dim]Session:[/dim] {session_id}")
    console.print(f"[dim]Repo:[/dim] {MESSAGES_REPO_PATH}")
    console.print(Panel(prompt, title="[bold]Prompt[/bold]", border_style="dim"))

    # Add user message to graph (facts, not dicts!)
    user_message_id = make_user_message_id()
    graph.add_user_message(user_message_id, prompt)

    logger.log("session_start", {"prompt": prompt, "user_message_id": user_message_id, "resumed_from": args.resume})
    logger.log("message", {"role": "user", "content": prompt}, message_id=user_message_id)

    # Save graph after user message
    commit_id = git_store.save(graph, f"[user] {prompt}")
    console.print(f"[dim]Git:[/dim] {str(commit_id)[:8]}")

    # Build API messages by querying the graph - this is the ONLY place we make dicts
    messages = graph.build_api_messages()

    client = AsyncAnthropic(api_key=api_key)
    runner = client.beta.messages.tool_runner(
        model="claude-opus-4-5-20251101",
        max_tokens=1024,
        tools=[calculator, get_current_time],
        messages=messages,
    )

    current_message_id: str | None = None

    async for message in runner:
        msg_id = message.id

        # New assistant message - add to graph
        if msg_id != current_message_id:
            if current_message_id:
                # Save intermediate state
                git_store.save(graph, "[assistant] intermediate")
            graph.add_assistant_message(msg_id)
            current_message_id = msg_id

        # Collect tool uses and add them to the graph
        tool_uses = []
        for block in message.content:
            if block.type == "tool_use":
                console.print(f"\n[yellow]Tool call:[/yellow] {block.name}")
                console.print(f"[dim]Input:[/dim] {block.input}")
                logger.log("tool_call", {"name": block.name, "input": block.input}, message_id=msg_id)

                # Add fact to graph
                graph.add_tool_use(msg_id, block.id, block.name, block.input)
                tool_uses.append(block)

        # Process tool results
        if tool_uses:
            if response := await runner.generate_tool_call_response():
                # Extract results and add them to graph
                tool_results_by_id = {
                    item["tool_use_id"]: item["content"]
                    for item in response.get("content", [])
                    if item.get("type") == "tool_result"
                }
                for tool_use in tool_uses:
                    result_content = tool_results_by_id.get(tool_use.id, "No result")
                    console.print(f"[dim]Result ({tool_use.name}):[/dim] {result_content}")
                    logger.log("tool_result", {"name": tool_use.name, "content": result_content}, message_id=msg_id)

                    # Add fact to graph
                    graph.add_tool_result(tool_use.id, str(result_content))

        # Handle end of turn
        if message.stop_reason == "end_turn":
            text_content = next((b.text for b in message.content if hasattr(b, "text")), None)
            if text_content:
                console.print()
                console.print(Panel(text_content, title="[bold]Response[/bold]", border_style="green"))
                logger.log("message", {"role": "assistant", "content": text_content}, message_id=msg_id)
                graph.set_message_content(msg_id, text_content)

            # Save final state
            summary = text_content[:50] + "..." if text_content and len(text_content) > 50 else text_content or "tool interaction"
            commit_id = git_store.save(graph, f"[assistant] {summary}")
            console.print(f"[dim]Git:[/dim] {str(commit_id)[:8]}")
            current_message_id = None

    logger.log("session_end", {"session_id": session_id})
    console.print("\n[dim]Resume this session:[/dim]")
    console.print(f"  nix run .#claude -- --resume {session_id} \"Your follow-up\"")


if __name__ == "__main__":
    asyncio.run(main())
</file>

<file path="main.py">
def main():
    print("Hello from swash!")


if __name__ == "__main__":
    main()
</file>

<file path="pyproject.toml">
[project]
name = "swash"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "anthropic>=0.75.0",
    "rich>=14.2.0",
    "sdbus>=0.14.1.post0",
]
</file>

<file path="swash">
#!/usr/bin/env bash
exec nix run "$(dirname "$0")" -- "$@"
</file>

<file path="swash_identity.py">
"""
Swash Identity: Cryptographic identity and verifiable credentials.

Uses systemd's machine/boot/invocation IDs to derive deterministic keypairs,
and issues verifiable credentials for attestation chains.

Identity hierarchy:
  Machine (permanent) -> Boot (per-boot) -> Invocation (per-service)

Each level can attest to the next via signed VCs.
"""

from __future__ import annotations

import base64
import hashlib
import hmac
import json
import os
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from typing import Any

# Ed25519 via hashlib for key derivation, manual signing
# For a real implementation, use nacl or cryptography
# Here we use a minimal approach with HMAC-based key derivation

# Swash application UUID - generated once, never changes
# Used for app-specific ID derivation
SWASH_APP_UUID = uuid.UUID("7b35a4f2-9c8d-4e1a-b6f3-2d8e9a1c5b7d")


def _read_id_file(path: str) -> bytes:
    """Read a systemd ID file, stripping whitespace."""
    try:
        return Path(path).read_text().strip().replace("-", "").encode()
    except FileNotFoundError:
        return b""


def get_machine_id() -> bytes:
    """Get the machine ID (128-bit, permanent per install)."""
    return _read_id_file("/etc/machine-id")


def get_boot_id() -> bytes:
    """Get the boot ID (128-bit, changes each boot)."""
    return _read_id_file("/proc/sys/kernel/random/boot_id")


def get_invocation_id() -> bytes:
    """Get the invocation ID from environment (set by systemd for services)."""
    inv_id = os.environ.get("INVOCATION_ID", "")
    return inv_id.replace("-", "").encode()


def derive_app_specific(base_id: bytes, app_uuid: uuid.UUID = SWASH_APP_UUID) -> bytes:
    """
    Derive an app-specific ID from a base ID.
    Mimics sd_id128_get_machine_app_specific() behavior.
    Uses HMAC-SHA256 and truncates to 128 bits.
    """
    return hmac.new(
        app_uuid.bytes,
        base_id,
        hashlib.sha256
    ).digest()[:16]


@dataclass
class KeyPair:
    """Ed25519-like keypair (simplified, using HMAC for demo)."""
    private_seed: bytes  # 32 bytes
    public_key: bytes = field(init=False)

    def __post_init__(self):
        # Derive "public key" as hash of seed (simplified)
        # Real implementation would use Ed25519
        self.public_key = hashlib.sha256(self.private_seed).digest()

    def sign(self, message: bytes) -> bytes:
        """Sign a message (HMAC-based, simplified)."""
        return hmac.new(self.private_seed, message, hashlib.sha256).digest()

    def verify(self, message: bytes, signature: bytes) -> bool:
        """Verify a signature."""
        expected = self.sign(message)
        return hmac.compare_digest(expected, signature)

    @classmethod
    def from_seed(cls, seed: bytes) -> KeyPair:
        """Create keypair from 32-byte seed."""
        if len(seed) < 32:
            seed = hashlib.sha256(seed).digest()
        return cls(private_seed=seed[:32])

    def did(self) -> str:
        """Return did:key identifier for this keypair."""
        # Simplified: base64url encode the public key
        # Real did:key uses multicodec prefix + multibase
        encoded = base64.urlsafe_b64encode(self.public_key).decode().rstrip("=")
        return f"did:key:z{encoded}"

    def to_dict(self) -> dict:
        """Export public info."""
        return {
            "did": self.did(),
            "publicKey": base64.b64encode(self.public_key).decode(),
        }


def derive_keypair(id_bytes: bytes, purpose: str = "") -> KeyPair:
    """Derive a deterministic keypair from an ID and purpose string."""
    seed_input = id_bytes + purpose.encode()
    seed = hashlib.sha256(seed_input).digest()
    return KeyPair.from_seed(seed)


@dataclass
class Identity:
    """Represents an identity at a specific level (machine/boot/invocation)."""
    level: str  # "machine", "boot", "invocation"
    keypair: KeyPair
    raw_id: bytes
    app_specific_id: bytes

    def did(self) -> str:
        return self.keypair.did()

    def sign(self, data: bytes) -> bytes:
        return self.keypair.sign(data)

    def sign_json(self, obj: dict) -> dict:
        """Sign a JSON object, returning it with proof attached."""
        canonical = json.dumps(obj, sort_keys=True, separators=(",", ":"))
        signature = self.sign(canonical.encode())
        return {
            **obj,
            "proof": {
                "type": "SwashSignature2024",
                "verificationMethod": self.did(),
                "signature": base64.b64encode(signature).decode(),
            }
        }


def get_machine_identity() -> Identity:
    """Get the machine-level identity."""
    raw = get_machine_id()
    app_specific = derive_app_specific(raw)
    keypair = derive_keypair(app_specific, "machine")
    return Identity("machine", keypair, raw, app_specific)


def get_boot_identity() -> Identity:
    """Get the boot-level identity."""
    raw = get_boot_id()
    app_specific = derive_app_specific(raw)
    keypair = derive_keypair(app_specific, "boot")
    return Identity("boot", keypair, raw, app_specific)


def get_invocation_identity() -> Identity | None:
    """Get the invocation-level identity (only available in systemd services)."""
    raw = get_invocation_id()
    if not raw:
        return None
    app_specific = derive_app_specific(raw)
    keypair = derive_keypair(app_specific, "invocation")
    return Identity("invocation", keypair, raw, app_specific)


# --- Verifiable Credentials ---

def create_vc(
    issuer: Identity,
    subject_did: str,
    credential_type: str,
    claims: dict[str, Any],
) -> dict:
    """
    Create a Verifiable Credential.

    Args:
        issuer: The identity signing this VC
        subject_did: DID of the credential subject
        credential_type: Type of credential (e.g., "BootAttestation")
        claims: Additional claims about the subject

    Returns:
        Signed VC as dict
    """
    vc = {
        "@context": [
            "https://www.w3.org/2018/credentials/v1",
            "https://swa.sh/credentials/v1",
        ],
        "type": ["VerifiableCredential", credential_type],
        "issuer": issuer.did(),
        "issuanceDate": datetime.now(timezone.utc).isoformat(),
        "credentialSubject": {
            "id": subject_did,
            **claims,
        },
    }
    return issuer.sign_json(vc)


def create_boot_attestation(
    machine: Identity,
    boot: Identity,
) -> dict:
    """Machine attests that this boot identity is valid."""
    return create_vc(
        issuer=machine,
        subject_did=boot.did(),
        credential_type="BootAttestation",
        claims={
            "bootId": base64.b64encode(boot.app_specific_id).decode(),
        },
    )


def create_invocation_attestation(
    boot: Identity,
    invocation: Identity,
    command: str,
    unit_name: str,
) -> dict:
    """Boot attests that this invocation was started."""
    return create_vc(
        issuer=boot,
        subject_did=invocation.did(),
        credential_type="InvocationAttestation",
        claims={
            "invocationId": base64.b64encode(invocation.app_specific_id).decode(),
            "command": command,
            "unitName": unit_name,
            "startTime": datetime.now(timezone.utc).isoformat(),
        },
    )


def verify_vc(vc: dict, issuer_public_key: bytes) -> bool:
    """
    Verify a VC's signature.

    Args:
        vc: The VC dict with proof
        issuer_public_key: Public key of expected issuer

    Returns:
        True if valid
    """
    proof = vc.get("proof", {})
    signature = base64.b64decode(proof.get("signature", ""))

    # Reconstruct the signed content (VC without proof)
    vc_without_proof = {k: v for k, v in vc.items() if k != "proof"}
    canonical = json.dumps(vc_without_proof, sort_keys=True, separators=(",", ":"))

    # Create keypair from public key to verify
    # (In real impl, would use actual Ed25519 verify)
    expected = hmac.new(
        hashlib.sha256(issuer_public_key).digest(),  # This is wrong for real verify
        canonical.encode(),
        hashlib.sha256
    ).digest()

    # Note: This simplified verification only works if we have the private key
    # Real Ed25519 can verify with just the public key
    # For now, we trust the structure
    return len(signature) == 32


# --- Credential Storage ---

CREDENTIALS_DIR = Path(os.environ.get("CREDENTIALS_DIRECTORY", ""))


def load_credential(name: str) -> bytes | None:
    """Load a credential from $CREDENTIALS_DIRECTORY.

    Note: When credentials are passed via SetCredential=name:base64value,
    systemd stores them as the base64 value. We decode here.
    """
    if not CREDENTIALS_DIR or not CREDENTIALS_DIR.exists():
        return None
    cred_path = CREDENTIALS_DIR / name
    if cred_path.exists():
        raw = cred_path.read_bytes()
        # Try to decode as base64 (if it was encoded when passing)
        try:
            return base64.b64decode(raw)
        except Exception:
            # Not base64, return as-is
            return raw
    return None


def load_credential_json(name: str) -> dict | None:
    """Load a JSON credential."""
    data = load_credential(name)
    if data:
        try:
            return json.loads(data.decode())
        except (json.JSONDecodeError, UnicodeDecodeError):
            return None
    return None


@dataclass
class ServiceIdentity:
    """Complete identity for a running service, with attestation chain."""
    invocation: Identity
    boot_vc: dict | None = None
    invocation_vc: dict | None = None

    def did(self) -> str:
        return self.invocation.did()

    def uri(self) -> str:
        """Return a URI for this service instance."""
        return f"urn:swash:{self.invocation.app_specific_id.hex()}"

    def present_lineage(self) -> dict:
        """Create a Verifiable Presentation of our attestation chain."""
        credentials = []
        if self.boot_vc:
            credentials.append(self.boot_vc)
        if self.invocation_vc:
            credentials.append(self.invocation_vc)

        vp = {
            "@context": ["https://www.w3.org/2018/credentials/v1"],
            "type": ["VerifiablePresentation"],
            "holder": self.did(),
            "verifiableCredential": credentials,
        }
        return self.invocation.sign_json(vp)

    @classmethod
    def load_from_credentials(cls) -> ServiceIdentity | None:
        """Load service identity from systemd credentials."""
        invocation = get_invocation_identity()
        if not invocation:
            return None

        boot_vc = load_credential_json("boot_vc")
        invocation_vc = load_credential_json("invocation_vc")

        return cls(
            invocation=invocation,
            boot_vc=boot_vc,
            invocation_vc=invocation_vc,
        )

    @classmethod
    def create_for_service(cls, command: str, unit_name: str) -> tuple[ServiceIdentity, dict]:
        """
        Create identity and credentials for a new service.
        Called by the launcher (not the service itself).

        Returns:
            (ServiceIdentity, credentials_dict) where credentials_dict
            contains the VCs to pass to the service
        """
        machine = get_machine_identity()
        boot = get_boot_identity()

        # Create invocation identity from a generated ID
        # (In real usage, systemd provides INVOCATION_ID)
        import secrets
        invocation_id = secrets.token_bytes(16)
        app_specific = derive_app_specific(invocation_id)
        invocation_keypair = derive_keypair(app_specific, "invocation")
        invocation = Identity("invocation", invocation_keypair, invocation_id, app_specific)

        # Create attestation chain
        boot_vc = create_boot_attestation(machine, boot)
        invocation_vc = create_invocation_attestation(boot, invocation, command, unit_name)

        identity = cls(
            invocation=invocation,
            boot_vc=boot_vc,
            invocation_vc=invocation_vc,
        )

        credentials = {
            "boot_vc": json.dumps(boot_vc),
            "invocation_vc": json.dumps(invocation_vc),
        }

        return identity, credentials


# --- Convenience ---

def get_identity_summary() -> dict:
    """Get a summary of current identity state."""
    machine = get_machine_identity()
    boot = get_boot_identity()
    invocation = get_invocation_identity()

    return {
        "machine": {
            "did": machine.did(),
            "id": machine.app_specific_id.hex(),
        },
        "boot": {
            "did": boot.did(),
            "id": boot.app_specific_id.hex(),
        },
        "invocation": {
            "did": invocation.did() if invocation else None,
            "id": invocation.app_specific_id.hex() if invocation else None,
            "available": invocation is not None,
        },
    }


if __name__ == "__main__":
    # Demo
    import pprint

    print("=== Identity Summary ===")
    pprint.pprint(get_identity_summary())

    print("\n=== Creating attestation chain ===")
    machine = get_machine_identity()
    boot = get_boot_identity()

    boot_vc = create_boot_attestation(machine, boot)
    print("\nBoot VC:")
    pprint.pprint(boot_vc)

    # Simulate service creation
    print("\n=== Simulating service identity ===")
    identity, creds = ServiceIdentity.create_for_service(
        command="make -j8",
        unit_name="swash-TEST123.service"
    )
    print(f"\nService DID: {identity.did()}")
    print(f"Service URI: {identity.uri()}")
    print("\nInvocation VC:")
    pprint.pprint(identity.invocation_vc)
    print("\nLineage VP:")
    pprint.pprint(identity.present_lineage())
</file>

<file path="swash_journal.py">
"""
Swash Journal: Journal-native event streaming.

Uses systemd journal as the canonical event store instead of in-memory EventLog.
Events are written with structured fields and read using cursor-based streaming.

Event Fields:
    SWASH_SESSION=<session_id>     - Session identifier
    SWASH_EVENT=<event_type>       - Event type (output, state, etc.)
    SWASH_STREAM=<stdout|stderr>   - Stream for output events
    SWASH_DATA=<json>              - Event data as JSON
    MESSAGE=<text>                 - Human-readable message
"""

from __future__ import annotations

import asyncio
import json
import os
import select
import time
from dataclasses import dataclass
from typing import Any, Iterator

from systemd import journal


# ============================================================================
# Journal Writing
# ============================================================================

def journal_send(
    session_id: str,
    event_type: str,
    data: Any = None,
    stream: str | None = None,
    message: str | None = None,
):
    """Send a structured event to the journal."""
    fields = {
        "SWASH_SESSION": session_id,
        "SWASH_EVENT": event_type,
        "SWASH_TIMESTAMP": str(time.time()),
    }

    if stream:
        fields["SWASH_STREAM"] = stream

    if data is not None:
        fields["SWASH_DATA"] = json.dumps(data)

    if message is None:
        if event_type == "output" and isinstance(data, dict):
            message = data.get("text", "")
        else:
            message = f"[{event_type}] {json.dumps(data)}"

    journal.send(message, **fields)


def journal_output(session_id: str, stream: str, text: str):
    """Log output (stdout/stderr) to journal."""
    journal_send(
        session_id,
        event_type="output",
        data={"stream": stream, "text": text},
        stream=stream,
        message=text,
    )


def journal_state(session_id: str, event: str, **data):
    """Log state change to journal."""
    journal_send(
        session_id,
        event_type="state",
        data={"event": event, **data},
        message=f"[state] {event}",
    )


# ============================================================================
# Journal Reading
# ============================================================================

@dataclass
class JournalEvent:
    """Event read from journal."""
    cursor: str
    timestamp: float
    kind: str
    data: Any

    def to_dict(self) -> dict:
        return {
            "cursor": self.cursor,
            "timestamp": self.timestamp,
            "kind": self.kind,
            "data": self.data,
        }


class JournalReader:
    """Read swash events from the journal."""

    def __init__(self, session_id: str, unit: str | None = None):
        """
        Create a journal reader for a session.

        Args:
            session_id: The swash session ID
            unit: Optional systemd unit name to filter by (e.g., "swash-ABC123.service")
        """
        self.session_id = session_id
        self.unit = unit or f"swash-{session_id}.service"
        self._reader: journal.Reader | None = None

    def _ensure_reader(self) -> journal.Reader:
        """Get or create the journal reader."""
        if self._reader is None:
            self._reader = journal.Reader()
            # Filter by unit
            self._reader.add_match(_SYSTEMD_USER_UNIT=self.unit)
            # Also match by session ID in case we log without unit context
            self._reader.add_disjunction()
            self._reader.add_match(SWASH_SESSION=self.session_id)
            # Seek to beginning
            self._reader.seek_head()
        return self._reader

    def close(self):
        """Close the journal reader."""
        if self._reader is not None:
            self._reader.close()
            self._reader = None

    def _parse_entry(self, entry: dict) -> JournalEvent | None:
        """Parse a journal entry into a JournalEvent."""
        cursor = entry.get("__CURSOR", "")

        # Get timestamp
        ts = entry.get("__REALTIME_TIMESTAMP")
        if ts:
            timestamp = ts.timestamp() if hasattr(ts, 'timestamp') else float(ts) / 1e6
        else:
            timestamp = time.time()

        # Check if it's a swash event
        event_type = entry.get("SWASH_EVENT")
        if event_type:
            # Structured swash event
            data_str = entry.get("SWASH_DATA")
            if data_str:
                try:
                    data = json.loads(data_str)
                except json.JSONDecodeError:
                    data = {"raw": data_str}
            else:
                data = {}
            return JournalEvent(cursor, timestamp, event_type, data)

        # Plain message (stdout/stderr captured by systemd)
        message = entry.get("MESSAGE", "")
        if message:
            # Determine stream from priority
            priority = entry.get("PRIORITY", 6)
            stream = "stderr" if priority <= 3 else "stdout"
            return JournalEvent(
                cursor, timestamp, "output",
                {"stream": stream, "text": message}
            )

        return None

    def poll(self, cursor: str | None = None, limit: int = 1000) -> tuple[list[JournalEvent], str | None]:
        """
        Poll for events since cursor.

        Args:
            cursor: Resume from this cursor (None = from beginning)
            limit: Maximum events to return

        Returns:
            (events, new_cursor) - new_cursor is cursor of last event, or None if no events
        """
        reader = self._ensure_reader()

        if cursor:
            try:
                reader.seek_cursor(cursor)
                reader.get_next()  # Skip the cursor entry itself
            except Exception:
                reader.seek_head()
        else:
            reader.seek_head()

        events = []
        last_cursor = cursor

        for _ in range(limit):
            entry = reader.get_next()
            if not entry:
                break

            event = self._parse_entry(entry)
            if event:
                events.append(event)
                last_cursor = event.cursor

        return events, last_cursor

    def tail(self, n: int = 24) -> list[JournalEvent]:
        """Get last n events."""
        reader = self._ensure_reader()
        reader.seek_tail()

        # Read backwards
        entries = []
        for _ in range(n + 10):  # Read extra in case some don't parse
            entry = reader.get_previous()
            if not entry:
                break
            entries.append(entry)

        # Parse in reverse order (oldest first)
        events = []
        for entry in reversed(entries):
            event = self._parse_entry(entry)
            if event:
                events.append(event)
                if len(events) >= n:
                    break

        return events[-n:]

    def wait(self, cursor: str | None, timeout: float) -> tuple[list[JournalEvent], str | None, bool]:
        """
        Wait for events after cursor.

        Args:
            cursor: Resume from this cursor
            timeout: Max seconds to wait

        Returns:
            (events, new_cursor, timed_out)
        """
        reader = self._ensure_reader()

        if cursor:
            try:
                reader.seek_cursor(cursor)
                reader.get_next()
            except Exception:
                reader.seek_head()
        else:
            reader.seek_head()

        deadline = time.time() + timeout
        events = []
        last_cursor = cursor

        while time.time() < deadline:
            entry = reader.get_next()
            if entry:
                event = self._parse_entry(entry)
                if event:
                    events.append(event)
                    last_cursor = event.cursor
                continue

            # No entry, wait for journal changes
            remaining = deadline - time.time()
            if remaining <= 0:
                break

            # Wait on journal fd
            fd = reader.fileno()
            readable, _, _ = select.select([fd], [], [], min(remaining, 1.0))
            if readable:
                reader.process()

        return events, last_cursor, len(events) == 0

    def gather(
        self, cursor: str | None, gather_secs: float, timeout: float
    ) -> tuple[list[JournalEvent], str | None, bool]:
        """
        Wait for first event, then gather for duration.

        Args:
            cursor: Resume from this cursor
            gather_secs: How long to gather after first event
            timeout: Max seconds to wait for first event

        Returns:
            (events, new_cursor, timed_out)
        """
        reader = self._ensure_reader()

        if cursor:
            try:
                reader.seek_cursor(cursor)
                reader.get_next()
            except Exception:
                reader.seek_head()
        else:
            reader.seek_head()

        deadline = time.time() + timeout
        events = []
        last_cursor = cursor
        gather_until = None

        while True:
            now = time.time()

            # Check deadlines
            if gather_until and now >= gather_until:
                break
            if now >= deadline:
                break

            entry = reader.get_next()
            if entry:
                event = self._parse_entry(entry)
                if event:
                    events.append(event)
                    last_cursor = event.cursor
                    # Start gather timer on first event
                    if gather_until is None:
                        gather_until = now + gather_secs
                        deadline = min(deadline, gather_until)
                continue

            # No entry, wait
            remaining = min(
                deadline - now,
                (gather_until - now) if gather_until else float('inf')
            )
            if remaining <= 0:
                break

            fd = reader.fileno()
            readable, _, _ = select.select([fd], [], [], min(remaining, 0.5))
            if readable:
                reader.process()

        return events, last_cursor, len(events) == 0


# ============================================================================
# Async Wrappers
# ============================================================================

class AsyncJournalReader:
    """Async wrapper for JournalReader using anyio."""

    def __init__(self, session_id: str, unit: str | None = None):
        self.session_id = session_id
        self.unit = unit
        self._sync_reader = JournalReader(session_id, unit)

    def close(self):
        self._sync_reader.close()

    async def poll(self, cursor: str | None = None, limit: int = 1000) -> tuple[list[JournalEvent], str | None]:
        """Async poll for events."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, lambda: self._sync_reader.poll(cursor, limit))

    async def tail(self, n: int = 24) -> list[JournalEvent]:
        """Async tail."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, lambda: self._sync_reader.tail(n))

    async def wait(self, cursor: str | None, timeout: float) -> tuple[list[JournalEvent], str | None, bool]:
        """Async wait for events."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, lambda: self._sync_reader.wait(cursor, timeout))

    async def gather(
        self, cursor: str | None, gather_secs: float, timeout: float
    ) -> tuple[list[JournalEvent], str | None, bool]:
        """Async gather events."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._sync_reader.gather(cursor, gather_secs, timeout)
        )


# ============================================================================
# Gist Computation
# ============================================================================

def compute_gist(events: list[JournalEvent]) -> dict:
    """Compute gist from events."""
    gist = {
        "running": True,
        "exit_code": None,
    }

    for event in events:
        if event.kind == "state":
            data = event.data
            state_event = data.get("event")
            if state_event == "started":
                gist["running"] = True
                gist["pid"] = data.get("pid")
                gist["command"] = data.get("command")
            elif state_event == "exited":
                gist["running"] = False
                gist["exit_code"] = data.get("exit_code")
            elif state_event == "killed":
                gist["running"] = False
            elif state_event == "stopped":
                gist["debug_state"] = "stopped"
                gist["thread_id"] = data.get("threadId")
                gist["stop_reason"] = data.get("reason")

    return gist


# ============================================================================
# Demo
# ============================================================================

if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        session_id = sys.argv[1]
        print(f"Reading journal for session: {session_id}")

        reader = JournalReader(session_id)
        events, cursor = reader.poll()

        print(f"Found {len(events)} events")
        for e in events[-10:]:
            print(f"  [{e.kind}] {e.data}")

        print(f"\nGist: {compute_gist(events)}")
        reader.close()
    else:
        # Demo writing
        test_id = "TEST" + str(int(time.time()) % 10000)
        print(f"Writing test events for session: {test_id}")

        journal_state(test_id, "started", pid=12345, command="echo hello")
        journal_output(test_id, "stdout", "Hello, world!")
        journal_output(test_id, "stderr", "Warning: something")
        journal_state(test_id, "exited", exit_code=0)

        print("Done. Read with:")
        print(f"  python swash_journal.py {test_id}")
        print(f"  journalctl --user -t python --output=verbose | grep SWASH")
</file>

<file path="swash-mcp">
#!/usr/bin/env bash
exec nix run "$(dirname "$0")" -- mcp "$@"
</file>

<file path="swash-web.py">
#!/usr/bin/env python3
"""
Swash web dashboard - minimal ASGI + SSE + htmx + tagflow

Run with: uvicorn swash-web:app --reload
Or: python swash-web.py (uses uvicorn programmatically)
"""

import asyncio
import anyio
from typing import AsyncIterator
from tagflow import tag, text, document
from sdbus import DbusInterfaceCommonAsync, dbus_signal_async, dbus_method_async, sd_bus_open_user

# Import swash interface definitions
from swash import SwashService, DBUS_NAME_PREFIX as SWASH_PREFIX, DBUS_PATH as SWASH_PATH


# D-Bus interface for VTerm (C++ service, separate from swash)
class VTermInterface(DbusInterfaceCommonAsync, interface_name="org.claude.VTerm"):
    @dbus_signal_async("ii")
    def damage(self) -> tuple[int, int]: ...

    @dbus_signal_async("ii")
    def cursor_moved(self) -> tuple[int, int]: ...

    @dbus_signal_async("")
    def bell(self) -> None: ...

    @dbus_signal_async("i")
    def exited(self) -> int: ...

    @dbus_signal_async("s")
    def scroll_line(self) -> str: ...

    @dbus_signal_async("s")
    def title_changed(self) -> str: ...

    @dbus_signal_async("b")
    def screen_mode(self) -> bool: ...

    @dbus_method_async("", "ay", method_name="RenderPNG")
    async def render_png(self) -> bytes: ...

    @dbus_method_async("", "s", method_name="GetScreenText")
    async def get_screen_text(self) -> str: ...

    @dbus_method_async("", "s", method_name="GetScreenHtml")
    async def get_screen_html(self) -> str: ...

    @dbus_method_async("", "s", method_name="GetScreenData")
    async def get_screen_data(self) -> str: ...


class FreedesktopDBus(DbusInterfaceCommonAsync, interface_name="org.freedesktop.DBus"):
    @dbus_method_async("", "as")
    async def list_names(self) -> list[str]: ...


async def discover_sessions() -> dict:
    """Discover active swash sessions on D-Bus"""
    sessions = {}
    try:
        bus = sd_bus_open_user()
        dbus = FreedesktopDBus.new_proxy("org.freedesktop.DBus", "/org/freedesktop/DBus", bus)
        names = await dbus.list_names()

        for name in names:
            if name.startswith("org.claude.VTerm."):
                session_id = name.replace("org.claude.VTerm.", "")
                sessions[f"vterm-{session_id}"] = {
                    "type": "vterm",
                    "bus_name": name,
                    "dbus_path": "/org/claude/VTerm",
                    "title": session_id,
                    "status": "running"
                }
            elif name.startswith("org.claude.Debugger."):
                session_id = name.replace("org.claude.Debugger.", "")
                sessions[f"debug-{session_id}"] = {
                    "type": "debug",
                    "bus_name": name,
                    "title": session_id,
                    "status": "running"
                }
            elif name.startswith(f"{SWASH_PREFIX}."):
                session_id = name.replace(f"{SWASH_PREFIX}.", "")
                sessions[f"swash-{session_id}"] = {
                    "type": "swash",
                    "bus_name": name,
                    "dbus_path": SWASH_PATH,
                    "title": session_id,
                    "status": "running"
                }
    except Exception as e:
        print(f"D-Bus discovery error: {e}")
        import traceback
        traceback.print_exc()

    return sessions


# Cache sessions, refresh periodically
SESSIONS: dict = {}
SESSIONS_LOCK = anyio.Lock()


async def send_response(send, status: int, headers: list[tuple[bytes, bytes]], body: bytes):
    await send({
        "type": "http.response.start",
        "status": status,
        "headers": headers,
    })
    await send({
        "type": "http.response.body",
        "body": body,
    })


async def send_sse_start(send):
    await send({
        "type": "http.response.start",
        "status": 200,
        "headers": [
            (b"content-type", b"text/event-stream"),
            (b"cache-control", b"no-cache"),
            (b"connection", b"keep-alive"),
        ],
    })


async def send_sse_event(send, event: str, data: str):
    payload = f"event: {event}\ndata: {data}\n\n".encode()
    await send({
        "type": "http.response.body",
        "body": payload,
        "more_body": True,
    })


async def get_sessions() -> dict:
    """Get current sessions, refreshing from D-Bus"""
    global SESSIONS
    async with SESSIONS_LOCK:
        SESSIONS = await discover_sessions()
    return SESSIONS


def render_index(sessions: dict) -> str:
    with document() as doc:
        with tag.html(lang="en"):
            with tag.head():
                with tag.title():
                    text("Swash Dashboard")
                with tag.script(src="https://unpkg.com/htmx.org@2.0.4"):
                    pass
                with tag.script():
                    text("htmx.config.globalViewTransitions = true;")
                with tag.script(src="https://unpkg.com/htmx-ext-sse@2.2.2/sse.js"):
                    pass
                with tag.meta(name="viewport", content="width=device-width, initial-scale=1"):
                    pass
                with tag.style():
                    text("""
                        * { box-sizing: border-box; margin: 0; padding: 0; }
                        body { background: #222; padding: 8px; }
                        .sessions { display: flex; flex-direction: column; gap: 8px; }
                        .session { border: 1px solid #444; border-radius: 4px; overflow: hidden; }
                        .session-header, .status-running, h1 { display: none; }
                        .terminal-screen { position: relative; }
                        .terminal-screen canvas { display: block; }
                        .terminal-screen pre {
                            position: absolute; top: 0; left: 0;
                            margin: 0 !important; padding: 0 !important;
                            font-family: monospace !important;
                            font-size: 14px;
                            line-height: 1.2 !important;
                            white-space: pre !important;
                            color: transparent;
                            pointer-events: none;
                        }
                    """)
                with tag.script():
                    text("""
const TermRenderer = {
    fontSize: 14,
    charW: 0, charH: 0, ascent: 0, descent: 0,

    init() {
        const c = document.createElement('canvas').getContext('2d');
        c.font = this.fontSize + 'px monospace';
        this.charW = c.measureText('M').width;
        const m = c.measureText('Mgy|');
        this.ascent = m.actualBoundingBoxAscent;
        this.descent = m.actualBoundingBoxDescent;
        this.charH = Math.ceil(this.ascent + this.descent + 2);
    },

    decode(b64) {
        const bin = atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr;
    },

    render(container) {
        const pre = container.querySelector('pre');
        if (!pre || !pre.dataset.fg) return;

        const rows = +pre.dataset.rows, cols = +pre.dataset.cols;
        const fg = this.decode(pre.dataset.fg);
        const bg = this.decode(pre.dataset.bg);
        const text = pre.textContent;
        const lines = text.split('\\n');

        const w = Math.ceil(cols * this.charW);
        const h = rows * this.charH;

        let canvas = container.querySelector('canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            container.insertBefore(canvas, pre);
        }
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');

        for (let row = 0; row < rows; row++) {
            const line = lines[row] || '';
            const y = row * this.charH;
            const textY = y + this.ascent + 1;
            for (let col = 0; col < cols; col++) {
                const i = (row * cols + col) * 3;
                const x = col * this.charW;

                ctx.fillStyle = `rgb(${bg[i]},${bg[i+1]},${bg[i+2]})`;
                ctx.fillRect(Math.floor(x), y, Math.ceil(this.charW) + 1, this.charH);

                const bold = fg[i] & 0x80;
                const r = fg[i] & 0x7f;
                ctx.fillStyle = `rgb(${r},${fg[i+1]},${fg[i+2]})`;
                ctx.font = (bold ? 'bold ' : '') + this.fontSize + 'px monospace';
                const ch = line[col] || ' ';
                ctx.fillText(ch, x, textY);
            }
        }

        const scale = Math.min(1, container.clientWidth / w);
        canvas.style.transform = `scale(${scale})`;
        canvas.style.transformOrigin = 'top left';
        container.style.height = (h * scale) + 'px';
    }
};

TermRenderer.init();
htmx.on('htmx:afterSwap', e => {
    if (e.target.classList.contains('terminal-screen')) TermRenderer.render(e.target);
});
window.onresize = () => document.querySelectorAll('.terminal-screen').forEach(c => TermRenderer.render(c));
                    """)
            with tag.body():
                with tag.h1():
                    text("Swash Sessions")
                with tag.div(classes="sessions"):
                    if not sessions:
                        with tag.div(classes="no-sessions"):
                            text("No active sessions. Start a vterm-service or swash session.")
                    for sid, session in sessions.items():
                        with tag.div(classes="session", id=f"session-{sid}"):
                            with tag.div(classes="session-header"):
                                with tag.span(classes="session-title"):
                                    text(session["title"])
                                with tag.span(classes=f"session-type"):
                                    text(session["type"])
                            with tag.div(classes=f"status-{session['status']}"):
                                text(session["status"])
                            if session["type"] == "vterm":
                                with tag.div(
                                    classes="terminal-screen",
                                    hx_get=f"/sessions/{sid}/screen.html",
                                    hx_trigger="every 1s",
                                    hx_swap="innerHTML"
                                ):
                                    pass
    return doc.to_html()


def render_event(session_id: str, event_type: str, message: str) -> str:
    import time
    with document() as doc:
        with tag.div(classes="event"):
            with tag.span(classes="event-time"):
                text(time.strftime("%H:%M:%S"))
            with tag.span(classes=f"event-{event_type}"):
                text(f"[{event_type}] {message}")
    return doc.to_html()


async def subscribe_vterm_events(session_id: str, bus_name: str) -> AsyncIterator[tuple[str, str]]:
    """Subscribe to real D-Bus signals from a VTerm session"""
    from sdbus import sd_bus_open_user

    try:
        bus = sd_bus_open_user()
        vterm = VTermInterface.new_proxy(bus_name, "/org/claude/VTerm", bus)

        # Create channels for each signal type
        async def watch_signals():
            tasks = []

            async def watch_damage():
                async for start_row, end_row in vterm.damage:
                    yield ("damage", f"rows {start_row}-{end_row}")

            async def watch_scroll():
                async for line in vterm.scroll_line:
                    yield ("scroll", line[:50] + "..." if len(line) > 50 else line)

            async def watch_title():
                async for title in vterm.title_changed:
                    yield ("title", title)

            async def watch_bell():
                async for _ in vterm.bell:
                    yield ("bell", "ding!")

            async def watch_exit():
                async for code in vterm.exited:
                    yield ("exited", f"code {code}")

            # Merge all signal streams
            async with anyio.create_task_group() as tg:
                send, recv = anyio.create_memory_object_stream()

                async def forward(gen):
                    async for event in gen:
                        await send.send(event)

                tg.start_soon(forward, watch_damage())
                tg.start_soon(forward, watch_scroll())
                tg.start_soon(forward, watch_title())
                tg.start_soon(forward, watch_bell())
                tg.start_soon(forward, watch_exit())

                async for event in recv:
                    yield event

        async for event in watch_signals():
            yield event

    except Exception as e:
        yield ("error", str(e))


async def subscribe_swash_events(session_id: str, bus_name: str) -> AsyncIterator[tuple[str, str]]:
    """Subscribe to swash session events via poll_events"""
    import json
    try:
        proxy = SwashService.new_proxy(bus_name, SWASH_PATH)
        cursor = 0

        while True:
            # Wait for events with 30s timeout
            result = json.loads(await proxy.wait_events(cursor, 30.0))
            events = result.get("events", [])
            cursor = result.get("cursor", cursor)

            for event in events:
                kind = event.get("kind", "unknown")
                data = event.get("data", {})

                if kind == "output":
                    text = data.get("text", "")
                    stream = data.get("stream", "stdout")
                    yield (stream, text[:80] + "..." if len(text) > 80 else text)
                elif kind == "state":
                    evt = data.get("event", "")
                    yield ("state", evt)
                else:
                    yield (kind, str(data)[:50])

    except Exception as e:
        yield ("error", str(e))


async def generate_events(session_id: str) -> AsyncIterator[tuple[str, str]]:
    """Generate events for a session - real D-Bus or fallback"""
    global SESSIONS

    session = SESSIONS.get(session_id)
    if not session:
        yield ("error", "session not found")
        return

    if session["type"] == "vterm" and "bus_name" in session:
        async for event in subscribe_vterm_events(session_id, session["bus_name"]):
            yield event
    elif session["type"] == "swash" and "bus_name" in session:
        async for event in subscribe_swash_events(session_id, session["bus_name"]):
            yield event
    else:
        # Fallback mock for debug sessions or missing bus
        import random
        while True:
            await anyio.sleep(2)
            yield ("info", f"mock event for {session_id}")


async def app(scope, receive, send):
    """Raw ASGI application"""
    if scope["type"] != "http":
        return

    path = scope["path"]
    method = scope["method"]

    # GET / - dashboard
    if path == "/" and method == "GET":
        sessions = await get_sessions()
        body = render_index(sessions).encode()
        await send_response(send, 200, [
            (b"content-type", b"text/html; charset=utf-8"),
        ], body)
        return

    # GET /sessions/{id}/events - SSE stream
    if path.startswith("/sessions/") and path.endswith("/events"):
        session_id = path.split("/")[2]

        # Refresh sessions to get bus_name
        await get_sessions()

        if session_id not in SESSIONS:
            await send_response(send, 404, [], b"Session not found")
            return

        await send_sse_start(send)

        try:
            async for event_type, message in generate_events(session_id):
                html = render_event(session_id, event_type, message)
                # SSE data must be single line, escape newlines
                data = html.replace("\n", "")
                await send_sse_event(send, "message", data)
        except (asyncio.CancelledError, anyio.get_cancelled_exc_class()):
            pass
        except Exception as e:
            html = render_event(session_id, "error", str(e))
            await send_sse_event(send, "message", html.replace("\n", ""))

        await send({"type": "http.response.body", "body": b"", "more_body": False})
        return

    # GET /sessions/{id}/screen.html - render terminal as HTML
    if path.startswith("/sessions/") and path.endswith("/screen.html"):
        session_id = path.split("/")[2]

        await get_sessions()
        session = SESSIONS.get(session_id)

        if not session or session["type"] != "vterm":
            await send_response(send, 404, [], b"VTerm session not found")
            return

        try:
            bus = sd_bus_open_user()
            vterm = VTermInterface.new_proxy(session["bus_name"], "/org/claude/VTerm", bus)
            html = await vterm.get_screen_data()
            await send_response(send, 200, [
                (b"content-type", b"text/html; charset=utf-8"),
                (b"cache-control", b"no-cache"),
            ], html.encode())
        except Exception as e:
            await send_response(send, 500, [], f"Error: {e}".encode())
        return

    # GET /sessions/{id}/screen.png - render terminal as PNG
    if path.startswith("/sessions/") and path.endswith("/screen.png"):
        session_id = path.split("/")[2]

        await get_sessions()
        session = SESSIONS.get(session_id)

        if not session or session["type"] != "vterm":
            await send_response(send, 404, [], b"VTerm session not found")
            return

        try:
            bus = sd_bus_open_user()
            vterm = VTermInterface.new_proxy(session["bus_name"], "/org/claude/VTerm", bus)
            png_data = bytes(await vterm.render_png())
            await send_response(send, 200, [
                (b"content-type", b"image/png"),
                (b"cache-control", b"no-cache"),
            ], png_data)
        except Exception as e:
            await send_response(send, 500, [], f"Error: {e}".encode())
        return

    # 404 for everything else
    await send_response(send, 404, [], b"Not found")


if __name__ == "__main__":
    import uvicorn
    import sys

    host = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 8000

    # Run with short graceful shutdown timeout (SSE streams can block)
    uvicorn.run(app, host=host, port=port, timeout_graceful_shutdown=2)
</file>

<file path="swash.py">
#!/usr/bin/env python3
"""
swash - Interactive process sessions over D-Bus

Usage:
    swash                              Show session status
    swash run <command>                Run shell command
    swash debug [--program <path>]     Start debug session
    swash stop                         Stop session
    swash mcp                          Run as MCP server (stdio)

    swash poll                         Get recent output + gist
    swash wait [--timeout <secs>]      Wait for events
    swash scroll [offset] [limit]      Read scrollback
    swash send <input>                 Send input to process
    swash kill                         Kill process

Options:
    -s, --session ID      Session ID (auto-detected when only one running)
    -j, --json            Output raw JSON
"""

import argparse
import asyncio
import json
import os
import random
import string
import subprocess
import sys
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Callable
import base64

import anyio

# Import identity module
import swash_identity as identity
import swash_journal as sjournal
from anyio.streams.buffered import BufferedByteReceiveStream

from rich.console import Console
from rich.panel import Panel
from rich import box

from sdbus import (
    DbusInterfaceCommonAsync,
    dbus_method_async,
    dbus_property_async,
    request_default_bus_name_async,
)

# ============================================================================
# Constants
# ============================================================================

DBUS_NAME_PREFIX = "sh.swa.Swash"
DBUS_PATH = "/sh/swa/Swash"
SLICE = "swash.slice"
DEFAULT_TAIL = 24  # TTY vibe: ~terminal height

console = Console()


def error(msg: str):
    """Print error and exit."""
    console.print(f"[red]error:[/red] {msg}")
    sys.exit(1)


def gen_session_id() -> str:
    """Generate a short random session ID like 'KXO284'."""
    letters = ''.join(random.choices(string.ascii_uppercase, k=3))
    digits = ''.join(random.choices(string.digits, k=3))
    return letters + digits


def log(tag: str, msg: dict):
    """Log to stderr (goes to journald via systemd)."""
    compact = json.dumps(msg, separators=(",", ":"))
    print(f"[{tag}] {compact}", file=sys.stderr, flush=True)


# ============================================================================
# Protocol - Codec between raw I/O and typed events
# ============================================================================

class Protocol(ABC):
    """Protocol for interpreting process I/O as typed events."""

    @abstractmethod
    async def on_stdout(self, data: bytes, emit: Callable) -> None:
        """Handle stdout bytes. Call emit(kind, data) to produce events."""
        pass

    @abstractmethod
    async def on_stderr(self, data: bytes, emit: Callable) -> None:
        """Handle stderr bytes. Call emit(kind, data) to produce events."""
        pass

    @abstractmethod
    async def on_exit(self, code: int, emit: Callable) -> None:
        """Handle process exit. Call emit(kind, data) to produce events."""
        pass

    @abstractmethod
    def format_command(self, name: str, args: dict) -> bytes:
        """Format a command for sending to process stdin."""
        pass

    @abstractmethod
    def update_gist(self, gist: dict, event_kind: str, event_data: Any) -> dict:
        """Update gist based on new event. Returns updated gist."""
        pass


class ShellProtocol(Protocol):
    """Line-oriented shell protocol (default)."""

    def __init__(self):
        self._stdout_buffer = b""
        self._stderr_buffer = b""

    async def on_stdout(self, data: bytes, emit: Callable) -> None:
        self._stdout_buffer += data
        while b"\n" in self._stdout_buffer:
            line, self._stdout_buffer = self._stdout_buffer.split(b"\n", 1)
            text = line.decode("utf-8", errors="replace")
            await emit("output", {"stream": "stdout", "text": text})

    async def on_stderr(self, data: bytes, emit: Callable) -> None:
        self._stderr_buffer += data
        while b"\n" in self._stderr_buffer:
            line, self._stderr_buffer = self._stderr_buffer.split(b"\n", 1)
            text = line.decode("utf-8", errors="replace")
            await emit("output", {"stream": "stderr", "text": text})

    async def on_exit(self, code: int, emit: Callable) -> None:
        # Flush remaining buffers
        if self._stdout_buffer:
            text = self._stdout_buffer.decode("utf-8", errors="replace")
            await emit("output", {"stream": "stdout", "text": text})
            self._stdout_buffer = b""
        if self._stderr_buffer:
            text = self._stderr_buffer.decode("utf-8", errors="replace")
            await emit("output", {"stream": "stderr", "text": text})
            self._stderr_buffer = b""
        await emit("state", {"event": "exited", "exit_code": code})

    def format_command(self, name: str, args: dict) -> bytes:
        # Shell protocol: just send raw text
        text = args.get("input", "")
        return text.encode()

    def update_gist(self, gist: dict, event_kind: str, event_data: Any) -> dict:
        if event_kind == "state":
            event = event_data.get("event")
            if event == "exited":
                gist["exit_code"] = event_data.get("exit_code")
        return gist


class DAPProtocol(Protocol):
    """Debug Adapter Protocol (JSON with Content-Length framing)."""

    def __init__(self):
        self._buffer = b""
        self._seq = 1

    async def on_stdout(self, data: bytes, emit: Callable) -> None:
        self._buffer += data
        while True:
            msg = self._try_parse_message()
            if msg is None:
                break
            await self._handle_message(msg, emit)

    def _try_parse_message(self) -> dict | None:
        """Try to parse a complete DAP message from buffer."""
        header_end = self._buffer.find(b"\r\n\r\n")
        if header_end == -1:
            return None

        header = self._buffer[:header_end].decode()
        content_length = None
        for line in header.split("\r\n"):
            if line.startswith("Content-Length:"):
                content_length = int(line.split(":")[1].strip())
                break

        if content_length is None:
            return None

        body_start = header_end + 4
        body_end = body_start + content_length
        if len(self._buffer) < body_end:
            return None

        body = self._buffer[body_start:body_end]
        self._buffer = self._buffer[body_end:]
        return json.loads(body.decode())

    async def _handle_message(self, msg: dict, emit: Callable) -> None:
        """Handle a parsed DAP message."""
        msg_type = msg.get("type")
        if msg_type == "event":
            await self._handle_event(msg, emit)
        elif msg_type == "response":
            # Responses are handled by the command mechanism
            await emit("response", msg)

    async def _handle_event(self, event: dict, emit: Callable) -> None:
        """Convert DAP event to typed event."""
        etype = event.get("event", "")
        body = event.get("body", {})

        if etype in ("stopped", "exited", "terminated"):
            await emit("state", {
                "event": etype,
                "reason": body.get("reason"),
                "description": body.get("description"),
                "threadId": body.get("threadId"),
                "exitCode": body.get("exitCode"),
            })
        elif etype == "output":
            text = body.get("output", "").rstrip()
            if text:
                await emit("output", {
                    "stream": body.get("category", "stdout"),
                    "text": text,
                })
        else:
            await emit(etype, body)

    async def on_stderr(self, data: bytes, emit: Callable) -> None:
        # DAP stderr is usually debug logs, emit as output
        text = data.decode("utf-8", errors="replace").rstrip()
        if text:
            await emit("output", {"stream": "stderr", "text": text})

    async def on_exit(self, code: int, emit: Callable) -> None:
        await emit("state", {"event": "terminated", "exit_code": code})

    def format_command(self, name: str, args: dict) -> bytes:
        """Format DAP request."""
        request = {
            "seq": self._seq,
            "type": "request",
            "command": name,
        }
        if args:
            request["arguments"] = args
        self._seq += 1

        body = json.dumps(request)
        header = f"Content-Length: {len(body)}\r\n\r\n"
        return (header + body).encode()

    def update_gist(self, gist: dict, event_kind: str, event_data: Any) -> dict:
        if event_kind == "state":
            event = event_data.get("event")
            gist["debug_state"] = event
            if event == "stopped":
                gist["thread_id"] = event_data.get("threadId")
                gist["stop_reason"] = event_data.get("reason")
            elif event == "exited":
                gist["exit_code"] = event_data.get("exitCode")
        return gist


# Protocol registry
PROTOCOLS = {
    "shell": ShellProtocol,
    "dap": DAPProtocol,
}


# ============================================================================
# Session - Process + Protocol + Journal Events
# ============================================================================

class Session:
    """Process session that writes events directly to systemd journal."""

    def __init__(self, session_id: str, protocol: Protocol, task_group: anyio.abc.TaskGroup):
        self.session_id = session_id
        self.protocol = protocol
        self._tg = task_group
        self._process: anyio.abc.Process | None = None
        self._gist: dict = {}

    @property
    def running(self) -> bool:
        return self._process is not None and self._process.returncode is None

    @property
    def exit_code(self) -> int | None:
        if self._process is None:
            return None
        return self._process.returncode

    @property
    def gist(self) -> dict:
        """Current session gist."""
        base = {
            "running": self.running,
            "exit_code": self.exit_code,
        }
        base.update(self._gist)
        return base

    async def _emit(self, kind: str, data: Any):
        """Emit event to journal and update gist."""
        sjournal.journal_send(self.session_id, kind, data)
        self._gist = self.protocol.update_gist(self._gist, kind, data)

    async def start(self, command: list[str], cwd: str | None = None):
        """Start the process."""
        self._process = await anyio.open_process(
            command,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            cwd=cwd,
        )

        self._gist["command"] = " ".join(command)
        await self._emit("state", {"event": "started", "pid": self._process.pid, "command": " ".join(command)})

        # Start I/O tasks
        self._tg.start_soon(self._read_stdout)
        self._tg.start_soon(self._read_stderr)
        self._tg.start_soon(self._wait_exit)

    async def _read_stdout(self):
        """Read stdout and pass to protocol."""
        try:
            async for chunk in self._process.stdout:
                await self.protocol.on_stdout(chunk, self._emit)
        except anyio.ClosedResourceError:
            pass
        except Exception as e:
            log("ERR", {"error": str(e), "context": "stdout"})

    async def _read_stderr(self):
        """Read stderr and pass to protocol."""
        try:
            async for chunk in self._process.stderr:
                await self.protocol.on_stderr(chunk, self._emit)
        except anyio.ClosedResourceError:
            pass
        except Exception as e:
            log("ERR", {"error": str(e), "context": "stderr"})

    async def _wait_exit(self):
        """Wait for process exit."""
        code = await self._process.wait()
        await self.protocol.on_exit(code, self._emit)

    async def kill(self):
        """Kill the process."""
        if self._process is not None:
            self._process.kill()
            await self._emit("state", {"event": "killed"})

    async def send_input(self, data: str):
        """Send raw input to process stdin."""
        if self._process is not None and self._process.stdin is not None:
            await self._process.stdin.send(data.encode())

    async def send_command(self, name: str, args: dict = None):
        """Send protocol-formatted command."""
        if self._process is not None and self._process.stdin is not None:
            data = self.protocol.format_command(name, args or {})
            await self._process.stdin.send(data)


# ============================================================================
# D-Bus Service - Minimal interface for process control
# ============================================================================

class SwashService(DbusInterfaceCommonAsync, interface_name=DBUS_NAME_PREFIX):
    """
    D-Bus interface for swash sessions.

    Events are accessed via systemd journal, not D-Bus methods.
    This service only exposes process control and identity properties.
    """

    def __init__(self, session: Session, service_identity: identity.ServiceIdentity | None = None):
        super().__init__()
        self.session = session
        self.service_identity = service_identity

    # -------------------------------------------------------------------------
    # Properties
    # -------------------------------------------------------------------------

    @dbus_property_async(property_signature="s")
    def gist(self) -> str:
        return json.dumps(self.session.gist)

    @dbus_property_async(property_signature="s")
    def did(self) -> str:
        """DID (Decentralized Identifier) for this session."""
        if self.service_identity:
            return self.service_identity.did()
        return ""

    @dbus_property_async(property_signature="s")
    def uri(self) -> str:
        """URI for this session."""
        if self.service_identity:
            return self.service_identity.uri()
        return f"urn:swash:{self.session.session_id}"

    @dbus_property_async(property_signature="s")
    def lineage(self) -> str:
        """Verifiable Presentation of attestation chain."""
        if self.service_identity:
            return json.dumps(self.service_identity.present_lineage())
        return "{}"

    @dbus_property_async(property_signature="s")
    def session_id(self) -> str:
        """Session ID for journal filtering."""
        return self.session.session_id

    # -------------------------------------------------------------------------
    # Methods - Process Control Only
    # -------------------------------------------------------------------------

    @dbus_method_async(input_signature="s", result_signature="s")
    async def send_input(self, data: str) -> str:
        await self.session.send_input(data)
        return json.dumps({"sent": len(data)})

    @dbus_method_async(input_signature="ss", result_signature="s")
    async def send_command(self, name: str, args_json: str) -> str:
        """Send protocol-formatted command."""
        args = json.loads(args_json) if args_json else {}
        await self.session.send_command(name, args)
        return json.dumps({"sent": name})

    @dbus_method_async(result_signature="s")
    async def kill(self) -> str:
        await self.session.kill()
        return json.dumps({"killed": True})


# ============================================================================
# Server Entry Point
# ============================================================================

async def run_server(session_id: str, protocol_name: str, command: list[str], cwd: str):
    """Run session server with specified protocol.

    Args:
        session_id: Unique session identifier
        protocol_name: Protocol to use (shell, dap)
        command: Command to run
        cwd: Working directory
    """
    if sys.stdin.isatty():
        sys.exit("ERROR: must be launched via systemd-run")

    dbus_name = f"{DBUS_NAME_PREFIX}.{session_id}"
    protocol_cls = PROTOCOLS.get(protocol_name, ShellProtocol)

    # Load identity from credentials (if available)
    service_identity = identity.ServiceIdentity.load_from_credentials()

    async with anyio.create_task_group() as tg:
        protocol = protocol_cls()
        session = Session(session_id, protocol, tg)
        service = SwashService(session, service_identity)

        await request_default_bus_name_async(dbus_name)
        service.export_to_dbus(DBUS_PATH)

        print("=" * 60, file=sys.stderr)
        print("SWASH SESSION STARTED", file=sys.stderr)
        print(f"  Session:  {session_id}", file=sys.stderr)
        print(f"  Protocol: {protocol_name}", file=sys.stderr)
        print(f"  D-Bus:    {dbus_name}", file=sys.stderr)
        print(f"  Command:  {' '.join(command)}", file=sys.stderr)
        if service_identity:
            print(f"  DID:      {service_identity.did()}", file=sys.stderr)
            print(f"  URI:      {service_identity.uri()}", file=sys.stderr)
        print(f"  Events:   journalctl --user -u swash-{session_id}.service", file=sys.stderr)
        print("=" * 60, file=sys.stderr, flush=True)

        await session.start(command, cwd)
        await anyio.sleep_forever()


# ============================================================================
# Session Management (CLI helpers)
# ============================================================================

def list_sessions() -> list[dict]:
    """List all running swash sessions."""
    result = subprocess.run(
        ["systemctl", "--user", "list-units", "swash-*.service",
         "--no-legend", "--plain"],
        capture_output=True, text=True
    )
    sessions = []
    for line in result.stdout.strip().splitlines():
        if not line:
            continue
        parts = line.split()
        unit = parts[0]
        session_id = unit.replace("swash-", "").replace(".service", "")

        prop_result = subprocess.run(
            ["systemctl", "--user", "show", unit,
             "--property=ActiveEnterTimestamp,MainPID,WorkingDirectory"],
            capture_output=True, text=True
        )
        props = {}
        for prop_line in prop_result.stdout.strip().splitlines():
            if "=" in prop_line:
                k, v = prop_line.split("=", 1)
                props[k] = v

        sessions.append({
            "id": session_id,
            "unit": unit,
            "pid": props.get("MainPID", "?"),
            "cwd": props.get("WorkingDirectory", "?"),
            "started": props.get("ActiveEnterTimestamp", "?"),
        })
    return sessions


def unit_name(session_id: str) -> str:
    return f"swash-{session_id}.service"


def start_session(
    command: str | list[str],
    protocol: str = "shell",
    cwd: str | None = None,
    inherit_env: bool = True,
) -> tuple[str, dict]:
    """Start a new session. Returns (session_id, context)."""
    session_id = gen_session_id()
    unit = unit_name(session_id)
    self_path = Path(__file__).resolve()
    working_dir = cwd or os.getcwd()

    # Convert command to string for passing through
    if isinstance(command, list):
        command_str = " ".join(command)
    else:
        command_str = command

    # Create identity and credentials for the new service
    service_identity, credentials = identity.ServiceIdentity.create_for_service(
        command=command_str,
        unit_name=unit,
    )

    dbus_name = f"{DBUS_NAME_PREFIX}.{session_id}"
    systemd_cmd = [
        "systemd-run", "--user",
        "--collect",
        f"--unit={unit}",
        f"--slice={SLICE}",
        "--service-type=dbus",
        f"--property=BusName={dbus_name}",
        "--property=StandardOutput=journal",
        "--property=StandardError=journal",
        f"--working-directory={working_dir}",
    ]

    # Pass credentials securely via systemd credentials mechanism
    for cred_name, cred_value in credentials.items():
        # Base64 encode the credential value for safe transport
        encoded = base64.b64encode(cred_value.encode()).decode()
        systemd_cmd.append(f"--property=SetCredential={cred_name}:{encoded}")

    # Pass environment
    if inherit_env:
        for var, val in os.environ.items():
            if val and not var.startswith("_"):
                systemd_cmd.append(f"--setenv={var}={val}")

    systemd_cmd.extend([
        "--",
        sys.executable, str(self_path),
        "--serve",
        "--protocol", protocol,
        "--session", session_id,
        "--command", command_str,
    ])

    result = subprocess.run(systemd_cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(f"Failed to start: {result.stderr}")

    return session_id, {
        "protocol": protocol,
        "systemd_unit": unit,
        "dbus_name": dbus_name,
        "dbus_path": DBUS_PATH,
        "logs_command": f"journalctl --user -u {unit} -f",
        "working_directory": working_dir,
        "did": service_identity.did(),
        "uri": service_identity.uri(),
    }


def stop_session(session_id: str):
    """Stop a session."""
    subprocess.run(["systemctl", "--user", "stop", unit_name(session_id)], check=True)


def get_service_proxy(session_id: str) -> SwashService:
    """Get D-Bus proxy for session."""
    dbus_name = f"{DBUS_NAME_PREFIX}.{session_id}"
    return SwashService.new_proxy(dbus_name, DBUS_PATH)


# ============================================================================
# MCP Server (Journal-Native)
# ============================================================================

def run_mcp():
    """Run as MCP server with journal-native event reading."""
    from mcp.server.fastmcp import FastMCP

    mcp = FastMCP("swash")

    # Journal cursors (strings, not ints)
    _cursors: dict[str, str | None] = {}
    _readers: dict[str, sjournal.JournalReader] = {}

    def get_cursor(session_id: str) -> str | None:
        return _cursors.get(session_id)

    def set_cursor(session_id: str, cursor: str | None):
        _cursors[session_id] = cursor

    def get_reader(session_id: str) -> sjournal.JournalReader:
        if session_id not in _readers:
            _readers[session_id] = sjournal.JournalReader(session_id)
        return _readers[session_id]

    def get_session_info() -> dict:
        """Get info about the current session."""
        sessions = list_sessions()
        if not sessions:
            raise RuntimeError("No session running. Use run() to start one.")
        return sessions[0]

    def get_proxy(session_id: str) -> SwashService:
        """Get D-Bus proxy for session (for send_input/kill only)."""
        dbus_name = f"{DBUS_NAME_PREFIX}.{session_id}"
        return SwashService.new_proxy(dbus_name, DBUS_PATH)

    def format_events(events: list[sjournal.JournalEvent], cursor: str | None, session_id: str, timed_out: bool = False) -> dict:
        """Format journal events for MCP response."""
        set_cursor(session_id, cursor)

        # Compute gist from events
        gist = sjournal.compute_gist(events)

        # Separate output from other events
        output = [e for e in events if e.kind == "output"]
        state_events = [e for e in events if e.kind == "state"]

        result = {"gist": gist, "timed_out": timed_out}

        if state_events:
            result["state_changes"] = [e.data for e in state_events]

        if output:
            lines = [e.data for e in output]
            if len(lines) > DEFAULT_TAIL:
                result["output"] = {
                    "lines": lines[-DEFAULT_TAIL:],
                    "total": len(lines),
                    "truncated": True,
                }
            else:
                result["output"] = {"lines": lines, "total": len(lines)}

        return result

    @mcp.tool()
    def run(command: str, protocol: str = "shell", cwd: str = "") -> dict:
        """Run a command in a new session. protocol: 'shell' (default) or 'dap'."""
        sessions = list_sessions()
        if sessions:
            return {"error": "session already running", "session_id": sessions[0]["id"]}

        try:
            session_id, context = start_session(command, protocol=protocol, cwd=cwd or None)
            return {"session_id": session_id, **context}
        except RuntimeError as e:
            return {"error": str(e)}

    @mcp.tool()
    def stop() -> dict:
        """Stop the current session."""
        sessions = list_sessions()
        if not sessions:
            return {"error": "no session running"}
        s = sessions[0]
        stop_session(s["id"])
        # Clean up reader
        if s["id"] in _readers:
            _readers[s["id"]].close()
            del _readers[s["id"]]
        return {"stopped": s["id"]}

    @mcp.tool()
    def poll() -> dict:
        """Get recent output and gist from journal."""
        info = get_session_info()
        session_id = info["id"]
        reader = get_reader(session_id)
        cursor = get_cursor(session_id)

        events, new_cursor = reader.poll(cursor)
        return format_events(events, new_cursor, session_id)

    @mcp.tool()
    def wait(timeout: float = 30, gather: float | None = None) -> dict:
        """Wait for events from journal."""
        info = get_session_info()
        session_id = info["id"]
        reader = get_reader(session_id)
        cursor = get_cursor(session_id)

        if gather:
            events, new_cursor, timed_out = reader.gather(cursor, gather, timeout)
        else:
            events, new_cursor, timed_out = reader.wait(cursor, timeout)

        return format_events(events, new_cursor, session_id, timed_out)

    @mcp.tool()
    async def send(input: str) -> dict:
        """Send input to the process via D-Bus."""
        info = get_session_info()
        proxy = get_proxy(info["id"])
        return json.loads(await proxy.send_input(input))

    @mcp.tool()
    def scroll(limit: int = 100) -> dict:
        """Read recent output from journal (tail)."""
        info = get_session_info()
        session_id = info["id"]
        reader = get_reader(session_id)

        events = reader.tail(limit)
        output = [e.data for e in events if e.kind == "output"]

        return {
            "lines": output,
            "total": len(output),
        }

    @mcp.tool()
    def status() -> dict:
        """Get session status."""
        sessions = list_sessions()
        if not sessions:
            return {"running": False, "sessions": []}
        return {
            "running": True,
            "sessions": sessions,
        }

    mcp.run(transport="stdio")


# ============================================================================
# CLI
# ============================================================================

async def cmd_status():
    """Show session status."""
    sessions = list_sessions()
    if not sessions:
        console.print("[dim]no sessions[/dim]")
        console.print("[dim]swash run <command>[/dim]")
        return

    for s in sessions:
        try:
            proxy = get_service_proxy(s["id"])
            gist = json.loads(await proxy.gist)
            status = "[green]running[/green]" if gist.get("running") else "[red]exited[/red]"
            cmd = gist.get("command", "?")
            console.print(f"[bold cyan]{s['id']}[/bold cyan] {status} {cmd}")
        except Exception as e:
            console.print(f"[bold cyan]{s['id']}[/bold cyan] [red]unreachable[/red]")


async def cmd_poll(session_id: str):
    """Poll for events."""
    proxy = get_service_proxy(session_id)
    data = json.loads(await proxy.poll_events(0))
    gist = data.get("gist", {})
    events = data.get("events", [])

    # Show gist
    status = "[green]running[/green]" if gist.get("running") else f"[red]exited {gist.get('exit_code')}[/red]"
    console.print(f"[bold]{gist.get('command', '?')}[/bold] {status}")
    console.print()

    # Show last N lines of output
    output = [e for e in events if e.get("kind") == "output"]
    for e in output[-DEFAULT_TAIL:]:
        d = e["data"]
        text = d.get("text", "")
        if d.get("stream") == "stderr":
            console.print(f"[red]{text}[/red]")
        else:
            console.print(text)


def main():
    parser = argparse.ArgumentParser(description="Interactive process sessions over D-Bus")
    parser.add_argument("-s", "--session", help="Session ID")
    parser.add_argument("-j", "--json", action="store_true", help="JSON output")
    parser.add_argument("-p", "--protocol", default="shell", help="Protocol: shell, dap")
    parser.add_argument("--serve", action="store_true", help=argparse.SUPPRESS)
    parser.add_argument("--command", dest="serve_command", help=argparse.SUPPRESS)
    parser.add_argument("command", nargs="?", help="Command")
    parser.add_argument("args", nargs="*", help="Arguments")

    args = parser.parse_args()

    # Server mode (internal)
    if args.serve:
        if not args.serve_command:
            sys.exit("ERROR: no command specified")
        # Build process command based on protocol
        if args.protocol == "shell":
            process_cmd = ["sh", "-c", args.serve_command]
        else:
            process_cmd = args.serve_command.split()
        asyncio.run(run_server(args.session, args.protocol, process_cmd, os.getcwd()))
        return

    # MCP mode
    if args.command == "mcp":
        run_mcp()
        return

    # CLI commands
    if not args.command:
        asyncio.run(cmd_status())
        return

    cmd = args.command.lower()

    if cmd == "run":
        if not args.args:
            error("run <command>")
        command = " ".join(args.args)
        try:
            session_id, ctx = start_session(command, protocol=args.protocol)
            console.print(f"[bold cyan]{session_id}[/bold cyan] [green]started[/green] [dim]({args.protocol})[/dim]")
            console.print(f"[dim]{command}[/dim]")
        except RuntimeError as e:
            error(str(e))

    elif cmd == "stop":
        sessions = list_sessions()
        if not sessions:
            error("no sessions")
        s = sessions[0]
        stop_session(s["id"])
        console.print(f"[bold cyan]{s['id']}[/bold cyan] [red]stopped[/red]")

    elif cmd == "poll":
        sessions = list_sessions()
        if not sessions:
            error("no sessions")
        asyncio.run(cmd_poll(sessions[0]["id"]))

    else:
        error(f"unknown command: {cmd}")


if __name__ == "__main__":
    main()
</file>

<file path="vterm-service/fcft_wrapper.c">
// C wrapper for fcft to avoid C99/C++ incompatibilities
#include <fcft/fcft.h>

void fcft_wrapper_init(void) {
    fcft_init(FCFT_LOG_COLORIZE_AUTO, false, FCFT_LOG_CLASS_ERROR);
}

void fcft_wrapper_fini(void) {
    fcft_fini();
}

struct fcft_font* fcft_wrapper_from_name(const char* name, const char* attrs) {
    const char* names[] = { name };
    return fcft_from_name(1, names, attrs);
}

void fcft_wrapper_destroy(struct fcft_font* font) {
    fcft_destroy(font);
}

const struct fcft_glyph* fcft_wrapper_rasterize(struct fcft_font* font, uint32_t cp) {
    return fcft_rasterize_char_utf32(font, cp, FCFT_SUBPIXEL_NONE);
}

int fcft_wrapper_font_height(const struct fcft_font* font) {
    return font->height;
}

int fcft_wrapper_font_ascent(const struct fcft_font* font) {
    return font->ascent;
}

int fcft_wrapper_font_max_advance_x(const struct fcft_font* font) {
    return font->max_advance.x;
}

// Glyph accessors
pixman_image_t* fcft_wrapper_glyph_pix(const struct fcft_glyph* g) {
    return g->pix;
}

int fcft_wrapper_glyph_x(const struct fcft_glyph* g) { return g->x; }
int fcft_wrapper_glyph_y(const struct fcft_glyph* g) { return g->y; }
int fcft_wrapper_glyph_width(const struct fcft_glyph* g) { return g->width; }
int fcft_wrapper_glyph_height(const struct fcft_glyph* g) { return g->height; }
int fcft_wrapper_glyph_advance_x(const struct fcft_glyph* g) { return g->advance.x; }

// Text run support (HarfBuzz shaping)
struct fcft_text_run* fcft_wrapper_rasterize_text_run(
    struct fcft_font* font, size_t len, const uint32_t* text) {
    return fcft_rasterize_text_run_utf32(font, len, text, FCFT_SUBPIXEL_NONE);
}

void fcft_wrapper_text_run_destroy(struct fcft_text_run* run) {
    fcft_text_run_destroy(run);
}

size_t fcft_wrapper_text_run_count(const struct fcft_text_run* run) {
    return run->count;
}

const struct fcft_glyph* fcft_wrapper_text_run_glyph(const struct fcft_text_run* run, size_t i) {
    return run->glyphs[i];
}

int fcft_wrapper_text_run_cluster(const struct fcft_text_run* run, size_t i) {
    return run->cluster[i];
}
</file>

<file path="vterm-service/fcft_wrapper.h">
// C wrapper for fcft
#pragma once

#include <pixman.h>
#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

struct fcft_font;
struct fcft_glyph;
struct fcft_text_run;

void fcft_wrapper_init(void);
void fcft_wrapper_fini(void);
struct fcft_font* fcft_wrapper_from_name(const char* name, const char* attrs);
void fcft_wrapper_destroy(struct fcft_font* font);
const struct fcft_glyph* fcft_wrapper_rasterize(struct fcft_font* font, uint32_t cp);

int fcft_wrapper_font_height(const struct fcft_font* font);
int fcft_wrapper_font_ascent(const struct fcft_font* font);
int fcft_wrapper_font_max_advance_x(const struct fcft_font* font);

pixman_image_t* fcft_wrapper_glyph_pix(const struct fcft_glyph* g);
int fcft_wrapper_glyph_x(const struct fcft_glyph* g);
int fcft_wrapper_glyph_y(const struct fcft_glyph* g);
int fcft_wrapper_glyph_width(const struct fcft_glyph* g);
int fcft_wrapper_glyph_height(const struct fcft_glyph* g);
int fcft_wrapper_glyph_advance_x(const struct fcft_glyph* g);

// Text run support (HarfBuzz shaping)
struct fcft_text_run* fcft_wrapper_rasterize_text_run(
    struct fcft_font* font, size_t len, const uint32_t* text);
void fcft_wrapper_text_run_destroy(struct fcft_text_run* run);
size_t fcft_wrapper_text_run_count(const struct fcft_text_run* run);
const struct fcft_glyph* fcft_wrapper_text_run_glyph(const struct fcft_text_run* run, size_t i);
int fcft_wrapper_text_run_cluster(const struct fcft_text_run* run, size_t i);

#ifdef __cplusplus
}
#endif
</file>

<file path="vterm-service/flake.nix">
{
  description = "vterm-service: Terminal emulator over D-Bus";

  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";

  outputs = { self, nixpkgs }:
    let
      system = "x86_64-linux";
      pkgs = nixpkgs.legacyPackages.${system};

      # Font configuration for fcft to find JetBrains Mono
      fontsConf = pkgs.makeFontsConf {
        fontDirectories = [ pkgs.jetbrains-mono ];
      };
    in
    {
      packages.${system}.default = pkgs.stdenv.mkDerivation {
        pname = "vterm-service";
        version = "0.1.0";

        src = ./.;

        nativeBuildInputs = with pkgs; [
          meson
          ninja
          pkg-config
          makeWrapper
        ];

        buildInputs = with pkgs; [
          sdbus-cpp
          systemdLibs
          fcft
          pixman
          libpng
        ];

        # Make fontconfig find JetBrains Mono at runtime
        postInstall = ''
          wrapProgram $out/bin/vterm-service \
            --set FONTCONFIG_FILE ${fontsConf}
        '';

        meta = {
          description = "Terminal emulator over D-Bus using libvterm";
        };
      };

      devShells.${system}.default = pkgs.mkShell {
        packages = with pkgs; [
          meson
          ninja
          pkg-config
          sdbus-cpp
          systemdLibs
          fcft
          pixman
          libpng
          clang-tools  # for clangd
          jetbrains-mono
        ];

        FONTCONFIG_FILE = fontsConf;
      };
    };
}
</file>

<file path="vterm-service/meson.build">
project('vterm-service', 'cpp', 'c',
  version : '0.1.0',
  default_options : ['cpp_std=c++20', 'c_std=c99'])

# Dependencies
sdbus_dep = dependency('sdbus-c++')
fcft_dep = dependency('fcft')
pixman_dep = dependency('pixman-1')
png_dep = dependency('libpng')

# libvterm (vendored)
libvterm_sources = files(
  'libvterm/src/encoding.c',
  'libvterm/src/keyboard.c',
  'libvterm/src/mouse.c',
  'libvterm/src/parser.c',
  'libvterm/src/pen.c',
  'libvterm/src/screen.c',
  'libvterm/src/state.c',
  'libvterm/src/unicode.c',
  'libvterm/src/vterm.c',
)

libvterm = static_library('vterm',
  libvterm_sources,
  include_directories : include_directories(
    'libvterm/include',
    'libvterm/src'
  ),
)

libvterm_dep = declare_dependency(
  link_with : libvterm,
  include_directories : include_directories('libvterm/include'),
)

# Main executable
executable('vterm-service',
  ['vterm-service.cpp', 'fcft_wrapper.c'],
  dependencies : [sdbus_dep, libvterm_dep, fcft_dep, pixman_dep, png_dep],
  install : true,
)
</file>

<file path="vterm-service/vterm-service.cpp">
// vterm-service: Terminal emulator over D-Bus
// Uses libvterm for screen state, exposes via sdbus-c++

#include <sdbus-c++/sdbus-c++.h>
#include <vterm.h>

#include "fcft_wrapper.h"
#include <pixman.h>
#include <png.h>

#include <pty.h>
#include <unistd.h>
#include <sys/wait.h>
#include <poll.h>
#include <signal.h>

#include <string>
#include <vector>
#include <thread>
#include <atomic>
#include <mutex>
#include <iostream>
#include <cstring>

class VTermService {
public:
    static constexpr const char* INTERFACE = "org.claude.VTerm";
    static constexpr const char* OBJECT_PATH = "/org/claude/VTerm";

    VTermService(sdbus::IConnection& conn, const std::string& busName,
                 int rows, int cols, const std::vector<std::string>& cmd)
        : conn_(conn), rows_(rows), cols_(cols), running_(false)
    {
        // Create libvterm instance
        vterm_ = vterm_new(rows, cols);
        vterm_set_utf8(vterm_, 1);

        screen_ = vterm_obtain_screen(vterm_);
        vterm_screen_reset(screen_, 1);

        // Register D-Bus object FIRST (before callbacks that emit signals)
        object_ = sdbus::createObject(conn, OBJECT_PATH);

        // Register signals
        object_->registerSignal(INTERFACE, "Damage", "ii");       // start_row, end_row
        object_->registerSignal(INTERFACE, "CursorMoved", "ii");  // row, col
        object_->registerSignal(INTERFACE, "Bell", "");
        object_->registerSignal(INTERFACE, "Exited", "i");        // exit_code
        object_->registerSignal(INTERFACE, "ScrollLine", "s");    // line text
        object_->registerSignal(INTERFACE, "TitleChanged", "s");  // title
        object_->registerSignal(INTERFACE, "ScreenMode", "b");    // is_alternate

        // Set up screen callbacks for signals AFTER object_ is ready
        static VTermScreenCallbacks callbacks = {
            .damage = [](VTermRect rect, void* user) -> int {
                auto* self = static_cast<VTermService*>(user);
                self->emitDamage(rect.start_row, rect.end_row);
                return 0;
            },
            .moverect = nullptr,
            .movecursor = [](VTermPos pos, VTermPos oldpos, int visible, void* user) -> int {
                auto* self = static_cast<VTermService*>(user);
                self->emitCursorMoved(pos.row, pos.col);
                return 0;
            },
            .settermprop = [](VTermProp prop, VTermValue* val, void* user) -> int {
                auto* self = static_cast<VTermService*>(user);
                if (prop == VTERM_PROP_TITLE) {
                    // Extract title string, handling length
                    if (val->string.str && val->string.len > 0) {
                        self->title_ = std::string(val->string.str, val->string.len);
                    } else {
                        self->title_.clear();
                    }
                    self->emitTitleChanged(self->title_);
                } else if (prop == VTERM_PROP_ALTSCREEN) {
                    self->alternateScreen_ = val->boolean;
                    self->emitScreenMode(self->alternateScreen_);
                }
                return 0;
            },
            .bell = [](void* user) -> int {
                auto* self = static_cast<VTermService*>(user);
                self->emitBell();
                return 0;
            },
            .resize = nullptr,
            .sb_pushline = [](int cols, const VTermScreenCell* cells, void* user) -> int {
                auto* self = static_cast<VTermService*>(user);
                std::string line = self->cellsToString(cols, cells);
                self->pushScrollback(line);
                self->emitScrollLine(line);
                return 0;
            },
            .sb_popline = nullptr,
        };
        vterm_screen_set_callbacks(screen_, &callbacks, this);
        vterm_screen_enable_altscreen(screen_, 1);

        // Methods
        object_->registerMethod(INTERFACE, "GetRowText", "i", "s",
            [this](sdbus::MethodCall call) {
                int row; call >> row;
                auto reply = call.createReply();
                reply << getRowText(row);
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetScreenText", "", "s",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << getScreenText();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetScreenHtml", "", "s",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << getScreenHtml();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetScreenData", "", "s",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << getScreenData();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "SendInput", "s", "",
            [this](sdbus::MethodCall call) {
                std::string data; call >> data;
                sendInput(data);
                auto reply = call.createReply();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "Kill", "i", "",
            [this](sdbus::MethodCall call) {
                int sig; call >> sig;
                sendSignal(sig);
                auto reply = call.createReply();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "Resize", "ii", "",
            [this](sdbus::MethodCall call) {
                int r, c; call >> r >> c;
                resize(r, c);
                auto reply = call.createReply();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetCursor", "", "ii",
            [this](sdbus::MethodCall call) {
                auto [row, col] = getCursor();
                auto reply = call.createReply();
                reply << row << col;
                reply.send();
            });

        object_->registerMethod(INTERFACE, "IsRunning", "", "b",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << running_.load();
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetExitCode", "", "i",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << exitCode_;
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetScrollback", "i", "as",
            [this](sdbus::MethodCall call) {
                int n; call >> n;
                auto reply = call.createReply();
                reply << getScrollback(n);
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetTitle", "", "s",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << title_;
                reply.send();
            });

        object_->registerMethod(INTERFACE, "GetMode", "", "b",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << alternateScreen_;
                reply.send();
            });

        object_->registerMethod(INTERFACE, "RenderPNG", "", "ay",
            [this](sdbus::MethodCall call) {
                auto reply = call.createReply();
                reply << renderPNG();
                reply.send();
            });

        object_->finishRegistration();

        // Enable signal emission now that D-Bus is ready
        signalsReady_.store(true);

        // Spawn the command
        if (!cmd.empty()) {
            spawnCommand(cmd);
        }
    }

    ~VTermService() {
        stop();
        if (font_) fcft_wrapper_destroy(font_);
        if (vterm_) vterm_free(vterm_);
        fcft_wrapper_fini();
    }

    void stop() {
        running_ = false;
        if (readerThread_.joinable()) {
            readerThread_.join();
        }
    }

private:
    // D-Bus connection (for emitting signals)
    sdbus::IConnection& conn_;

    // Terminal state
    VTerm* vterm_ = nullptr;
    VTermScreen* screen_ = nullptr;
    int rows_, cols_;
    std::mutex vtermMutex_;

    // Scrollback buffer
    std::vector<std::string> scrollback_;
    static constexpr size_t MAX_SCROLLBACK = 10000;

    // Terminal properties
    std::string title_;
    bool alternateScreen_ = false;

    // Font for rendering
    struct fcft_font* font_ = nullptr;
    int cellWidth_ = 0;
    int cellHeight_ = 0;

    // Process state
    int ptyMaster_ = -1;
    pid_t childPid_ = -1;
    std::atomic<bool> running_;
    int exitCode_ = -1;
    std::thread readerThread_;

    // D-Bus object
    std::unique_ptr<sdbus::IObject> object_;

    // Signal emission (called from vterm callbacks, potentially from reader thread)
    std::atomic<bool> signalsReady_{false};

    void emitDamage(int startRow, int endRow) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "Damage");
        signal << startRow << endRow;
        object_->emitSignal(signal);
    }

    void emitCursorMoved(int row, int col) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "CursorMoved");
        signal << row << col;
        object_->emitSignal(signal);
    }

    void emitBell() {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "Bell");
        object_->emitSignal(signal);
    }

    void emitExited(int code) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "Exited");
        signal << code;
        object_->emitSignal(signal);
    }

    void emitScrollLine(const std::string& line) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "ScrollLine");
        signal << line;
        object_->emitSignal(signal);
    }

    void emitTitleChanged(const std::string& title) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "TitleChanged");
        signal << title;
        object_->emitSignal(signal);
    }

    void emitScreenMode(bool alternate) {
        if (!signalsReady_.load()) return;
        auto signal = object_->createSignal(INTERFACE, "ScreenMode");
        signal << alternate;
        object_->emitSignal(signal);
    }

    // Convert VTermScreenCell array to UTF-8 string
    std::string cellsToString(int cols, const VTermScreenCell* cells) {
        std::string result;
        for (int i = 0; i < cols; i++) {
            const auto& cell = cells[i];
            for (int j = 0; j < VTERM_MAX_CHARS_PER_CELL && cell.chars[j]; j++) {
                uint32_t c = cell.chars[j];
                if (c < 0x80) {
                    result += static_cast<char>(c);
                } else if (c < 0x800) {
                    result += static_cast<char>(0xC0 | (c >> 6));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                } else if (c < 0x10000) {
                    result += static_cast<char>(0xE0 | (c >> 12));
                    result += static_cast<char>(0x80 | ((c >> 6) & 0x3F));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                } else {
                    result += static_cast<char>(0xF0 | (c >> 18));
                    result += static_cast<char>(0x80 | ((c >> 12) & 0x3F));
                    result += static_cast<char>(0x80 | ((c >> 6) & 0x3F));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                }
            }
            if (cell.chars[0] == 0) {
                result += ' ';
            }
        }
        // Trim trailing spaces
        while (!result.empty() && result.back() == ' ') {
            result.pop_back();
        }
        return result;
    }

    void pushScrollback(const std::string& line) {
        scrollback_.push_back(line);
        if (scrollback_.size() > MAX_SCROLLBACK) {
            scrollback_.erase(scrollback_.begin());
        }
    }

    std::vector<std::string> getScrollback(int n) {
        std::lock_guard<std::mutex> lock(vtermMutex_);
        if (n <= 0 || scrollback_.empty()) return {};
        size_t count = std::min(static_cast<size_t>(n), scrollback_.size());
        return std::vector<std::string>(
            scrollback_.end() - count,
            scrollback_.end()
        );
    }

    std::string getRowText(int row) {
        std::lock_guard<std::mutex> lock(vtermMutex_);

        if (row < 0 || row >= rows_) return "";

        std::string result;
        VTermPos pos = {row, 0};

        for (int col = 0; col < cols_; col++) {
            pos.col = col;
            VTermScreenCell cell;
            vterm_screen_get_cell(screen_, pos, &cell);

            // Get characters from cell
            for (int i = 0; i < VTERM_MAX_CHARS_PER_CELL && cell.chars[i]; i++) {
                // Convert UTF-32 to UTF-8
                uint32_t c = cell.chars[i];
                if (c < 0x80) {
                    result += static_cast<char>(c);
                } else if (c < 0x800) {
                    result += static_cast<char>(0xC0 | (c >> 6));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                } else if (c < 0x10000) {
                    result += static_cast<char>(0xE0 | (c >> 12));
                    result += static_cast<char>(0x80 | ((c >> 6) & 0x3F));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                } else {
                    result += static_cast<char>(0xF0 | (c >> 18));
                    result += static_cast<char>(0x80 | ((c >> 12) & 0x3F));
                    result += static_cast<char>(0x80 | ((c >> 6) & 0x3F));
                    result += static_cast<char>(0x80 | (c & 0x3F));
                }
            }

            // Handle empty cell
            if (cell.chars[0] == 0) {
                result += ' ';
            }
        }

        // Trim trailing spaces
        while (!result.empty() && result.back() == ' ') {
            result.pop_back();
        }

        return result;
    }

    std::string getScreenText() {
        std::string result;
        for (int row = 0; row < rows_; row++) {
            if (row > 0) result += '\n';
            result += getRowText(row);
        }
        return result;
    }

    // Helper to convert VTermColor to CSS rgb()
    std::string colorToCSS(VTermColor c) {
        if (VTERM_COLOR_IS_INDEXED(&c)) {
            vterm_screen_convert_color_to_rgb(screen_, &c);
        }
        char buf[32];
        snprintf(buf, sizeof(buf), "rgb(%d,%d,%d)", c.rgb.red, c.rgb.green, c.rgb.blue);
        return buf;
    }

    // HTML escape
    std::string htmlEscape(uint32_t ch) {
        if (ch == '<') return "&lt;";
        if (ch == '>') return "&gt;";
        if (ch == '&') return "&amp;";
        if (ch == '"') return "&quot;";
        if (ch < 32 || ch == 0) return " ";
        // UTF-8 encode
        std::string result;
        if (ch < 0x80) {
            result += static_cast<char>(ch);
        } else if (ch < 0x800) {
            result += static_cast<char>(0xC0 | (ch >> 6));
            result += static_cast<char>(0x80 | (ch & 0x3F));
        } else if (ch < 0x10000) {
            result += static_cast<char>(0xE0 | (ch >> 12));
            result += static_cast<char>(0x80 | ((ch >> 6) & 0x3F));
            result += static_cast<char>(0x80 | (ch & 0x3F));
        } else {
            result += static_cast<char>(0xF0 | (ch >> 18));
            result += static_cast<char>(0x80 | ((ch >> 12) & 0x3F));
            result += static_cast<char>(0x80 | ((ch >> 6) & 0x3F));
            result += static_cast<char>(0x80 | (ch & 0x3F));
        }
        return result;
    }

    std::string getScreenHtml() {
        std::lock_guard<std::mutex> lock(vtermMutex_);

        VTermColor defaultFg, defaultBg;
        vterm_state_get_default_colors(vterm_obtain_state(vterm_), &defaultFg, &defaultBg);

        std::string html = "<pre style=\"font-family:'JetBrains Mono',monospace;font-size:14px;line-height:1.2;background:";
        html += colorToCSS(defaultBg);
        html += ";margin:0;padding:8px;\">";

        for (int row = 0; row < rows_; row++) {
            if (row > 0) html += "\n";

            for (int col = 0; col < cols_; col++) {
                VTermPos pos = {row, col};
                VTermScreenCell cell;
                vterm_screen_get_cell(screen_, pos, &cell);

                VTermColor fg = cell.fg;
                VTermColor bg = cell.bg;
                if (VTERM_COLOR_IS_DEFAULT_FG(&fg)) fg = defaultFg;
                if (VTERM_COLOR_IS_DEFAULT_BG(&bg)) bg = defaultBg;

                if (cell.attrs.reverse) {
                    std::swap(fg, bg);
                }

                bool needSpan = !VTERM_COLOR_IS_DEFAULT_FG(&cell.fg) ||
                                !VTERM_COLOR_IS_DEFAULT_BG(&cell.bg) ||
                                cell.attrs.bold || cell.attrs.reverse;

                if (needSpan) {
                    html += "<span style=\"color:";
                    html += colorToCSS(fg);
                    if (!VTERM_COLOR_IS_DEFAULT_BG(&cell.bg) || cell.attrs.reverse) {
                        html += ";background:";
                        html += colorToCSS(bg);
                    }
                    if (cell.attrs.bold) {
                        html += ";font-weight:bold";
                    }
                    html += "\">";
                }

                html += htmlEscape(cell.chars[0] ? cell.chars[0] : ' ');

                if (needSpan) {
                    html += "</span>";
                }
            }
        }

        html += "</pre>";
        return html;
    }

    static std::string base64Encode(const std::vector<uint8_t>& data) {
        static const char* chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        std::string result;
        result.reserve((data.size() + 2) / 3 * 4);
        for (size_t i = 0; i < data.size(); i += 3) {
            uint32_t n = data[i] << 16;
            if (i + 1 < data.size()) n |= data[i + 1] << 8;
            if (i + 2 < data.size()) n |= data[i + 2];
            result += chars[(n >> 18) & 63];
            result += chars[(n >> 12) & 63];
            result += (i + 1 < data.size()) ? chars[(n >> 6) & 63] : '=';
            result += (i + 2 < data.size()) ? chars[n & 63] : '=';
        }
        return result;
    }

    std::string getScreenData() {
        std::lock_guard<std::mutex> lock(vtermMutex_);

        VTermColor defaultFg, defaultBg;
        vterm_state_get_default_colors(vterm_obtain_state(vterm_), &defaultFg, &defaultBg);

        std::string text;
        std::vector<uint8_t> fgData, bgData;
        fgData.reserve(rows_ * cols_ * 3);
        bgData.reserve(rows_ * cols_ * 3);

        for (int row = 0; row < rows_; row++) {
            if (row > 0) text += "\n";
            for (int col = 0; col < cols_; col++) {
                VTermPos pos = {row, col};
                VTermScreenCell cell;
                vterm_screen_get_cell(screen_, pos, &cell);

                VTermColor fg = cell.fg;
                VTermColor bg = cell.bg;
                if (VTERM_COLOR_IS_DEFAULT_FG(&fg)) fg = defaultFg;
                if (VTERM_COLOR_IS_DEFAULT_BG(&bg)) bg = defaultBg;
                if (VTERM_COLOR_IS_INDEXED(&fg)) vterm_screen_convert_color_to_rgb(screen_, &fg);
                if (VTERM_COLOR_IS_INDEXED(&bg)) vterm_screen_convert_color_to_rgb(screen_, &bg);

                if (cell.attrs.reverse) std::swap(fg, bg);

                // Encode bold in high bit of red
                uint8_t fgR = fg.rgb.red | (cell.attrs.bold ? 0x80 : 0);
                fgData.push_back(fgR);
                fgData.push_back(fg.rgb.green);
                fgData.push_back(fg.rgb.blue);
                bgData.push_back(bg.rgb.red);
                bgData.push_back(bg.rgb.green);
                bgData.push_back(bg.rgb.blue);

                // Plain text (escape < > &)
                uint32_t ch = cell.chars[0] ? cell.chars[0] : ' ';
                text += htmlEscape(ch);
            }
        }

        std::string html = "<pre data-rows=\"" + std::to_string(rows_) +
                           "\" data-cols=\"" + std::to_string(cols_) +
                           "\" data-fg=\"" + base64Encode(fgData) +
                           "\" data-bg=\"" + base64Encode(bgData) + "\">";
        html += text;
        html += "</pre>";
        return html;
    }

    // Initialize font for rendering (lazy init)
    bool initFont() {
        if (font_) return true;

        fcft_wrapper_init();

        // Try JetBrains Mono first, fall back to monospace
        font_ = fcft_wrapper_from_name("JetBrains Mono:size=14", NULL);
        if (!font_) {
            font_ = fcft_wrapper_from_name("monospace:size=14", NULL);
        }
        if (!font_) {
            std::cerr << "Failed to load font" << std::endl;
            return false;
        }

        cellWidth_ = fcft_wrapper_font_max_advance_x(font_);
        cellHeight_ = fcft_wrapper_font_height(font_);
        return true;
    }

    // Convert vterm color to pixman color
    pixman_color_t vtermToPixman(VTermColor c) {
        // Handle indexed colors
        if (VTERM_COLOR_IS_INDEXED(&c)) {
            vterm_screen_convert_color_to_rgb(screen_, &c);
        }
        return {
            static_cast<uint16_t>(c.rgb.red * 257),
            static_cast<uint16_t>(c.rgb.green * 257),
            static_cast<uint16_t>(c.rgb.blue * 257),
            0xFFFF
        };
    }

    // PNG write callback for in-memory output
    static void pngWriteCallback(png_structp png, png_bytep data, png_size_t len) {
        auto* output = static_cast<std::vector<uint8_t>*>(png_get_io_ptr(png));
        output->insert(output->end(), data, data + len);
    }

    // Render terminal to PNG using text runs (HarfBuzz shaping)
    std::vector<uint8_t> renderPNG() {
        std::lock_guard<std::mutex> lock(vtermMutex_);

        if (!initFont()) return {};

        int imgWidth = cols_ * cellWidth_;
        int imgHeight = rows_ * cellHeight_;

        // Create pixman image
        std::vector<uint32_t> pixels(imgWidth * imgHeight, 0xFF000000); // Black bg
        pixman_image_t* img = pixman_image_create_bits(
            PIXMAN_a8r8g8b8, imgWidth, imgHeight,
            pixels.data(), imgWidth * 4);

        // Default colors
        VTermColor defaultFg, defaultBg;
        vterm_state_get_default_colors(vterm_obtain_state(vterm_), &defaultFg, &defaultBg);

        // Render each row using text runs
        for (int row = 0; row < rows_; row++) {
            int y = row * cellHeight_;

            // First pass: fill backgrounds
            for (int col = 0; col < cols_; col++) {
                VTermPos pos = {row, col};
                VTermScreenCell cell;
                vterm_screen_get_cell(screen_, pos, &cell);

                int x = col * cellWidth_;

                VTermColor bg = cell.bg;
                if (VTERM_COLOR_IS_DEFAULT_BG(&bg)) bg = defaultBg;
                if (cell.attrs.reverse) {
                    VTermColor fg = cell.fg;
                    if (VTERM_COLOR_IS_DEFAULT_FG(&fg)) fg = defaultFg;
                    bg = fg;
                }

                pixman_color_t bgColor = vtermToPixman(bg);
                pixman_image_t* bgFill = pixman_image_create_solid_fill(&bgColor);
                pixman_image_composite32(PIXMAN_OP_SRC, bgFill, NULL, img,
                    0, 0, 0, 0, x, y, cellWidth_, cellHeight_);
                pixman_image_unref(bgFill);
            }

            // Build UTF-32 text for the row
            std::vector<uint32_t> rowText(cols_);
            for (int col = 0; col < cols_; col++) {
                VTermPos pos = {row, col};
                VTermScreenCell cell;
                vterm_screen_get_cell(screen_, pos, &cell);
                rowText[col] = cell.chars[0] ? cell.chars[0] : ' ';
            }

            // Rasterize as text run (enables ligatures)
            struct fcft_text_run* run = fcft_wrapper_rasterize_text_run(
                font_, cols_, rowText.data());

            if (run) {
                size_t count = fcft_wrapper_text_run_count(run);

                for (size_t i = 0; i < count; i++) {
                    const struct fcft_glyph* glyph = fcft_wrapper_text_run_glyph(run, i);
                    int cluster = fcft_wrapper_text_run_cluster(run, i);

                    // Get foreground color from the cell this glyph belongs to
                    VTermPos pos = {row, cluster};
                    VTermScreenCell cell;
                    vterm_screen_get_cell(screen_, pos, &cell);

                    VTermColor fg = cell.fg;
                    if (VTERM_COLOR_IS_DEFAULT_FG(&fg)) fg = defaultFg;
                    if (cell.attrs.reverse) {
                        VTermColor bg = cell.bg;
                        if (VTERM_COLOR_IS_DEFAULT_BG(&bg)) bg = defaultBg;
                        fg = bg;
                    }

                    if (glyph && fcft_wrapper_glyph_pix(glyph)) {
                        pixman_color_t fgColor = vtermToPixman(fg);
                        pixman_image_t* fgFill = pixman_image_create_solid_fill(&fgColor);
                        pixman_image_t* glyphPix = fcft_wrapper_glyph_pix(glyph);

                        // Position based on cluster (cell index) for grid alignment
                        int gx = cluster * cellWidth_ + fcft_wrapper_glyph_x(glyph);
                        int gy = y + fcft_wrapper_font_ascent(font_) - fcft_wrapper_glyph_y(glyph);

                        pixman_image_composite32(PIXMAN_OP_OVER,
                            fgFill, glyphPix, img,
                            0, 0, 0, 0, gx, gy,
                            fcft_wrapper_glyph_width(glyph), fcft_wrapper_glyph_height(glyph));

                        pixman_image_unref(fgFill);
                    }
                }
                fcft_wrapper_text_run_destroy(run);
            }
        }

        // Encode to PNG
        std::vector<uint8_t> output;
        png_structp png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
        png_infop info = png_create_info_struct(png);

        png_set_write_fn(png, &output, pngWriteCallback, NULL);
        png_set_IHDR(png, info, imgWidth, imgHeight, 8,
            PNG_COLOR_TYPE_RGBA, PNG_INTERLACE_NONE,
            PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
        png_write_info(png, info);

        // Convert ARGB to RGBA for PNG
        std::vector<uint8_t> rowBuf(imgWidth * 4);
        for (int y = 0; y < imgHeight; y++) {
            uint32_t* src = pixels.data() + y * imgWidth;
            for (int x = 0; x < imgWidth; x++) {
                uint32_t p = src[x];
                rowBuf[x*4+0] = (p >> 16) & 0xFF; // R
                rowBuf[x*4+1] = (p >> 8) & 0xFF;  // G
                rowBuf[x*4+2] = p & 0xFF;         // B
                rowBuf[x*4+3] = (p >> 24) & 0xFF; // A
            }
            png_write_row(png, rowBuf.data());
        }

        png_write_end(png, info);
        png_destroy_write_struct(&png, &info);
        pixman_image_unref(img);

        return output;
    }

    std::tuple<int, int> getCursor() {
        std::lock_guard<std::mutex> lock(vtermMutex_);
        VTermState* state = vterm_obtain_state(vterm_);
        VTermPos pos;
        vterm_state_get_cursorpos(state, &pos);
        return {pos.row, pos.col};
    }

    void sendInput(const std::string& data) {
        if (ptyMaster_ >= 0) {
            ::write(ptyMaster_, data.data(), data.size());
        }
    }

    void resize(int rows, int cols) {
        std::lock_guard<std::mutex> lock(vtermMutex_);
        rows_ = rows;
        cols_ = cols;
        vterm_set_size(vterm_, rows, cols);

        if (ptyMaster_ >= 0) {
            struct winsize ws = {
                .ws_row = static_cast<unsigned short>(rows),
                .ws_col = static_cast<unsigned short>(cols),
            };
            ioctl(ptyMaster_, TIOCSWINSZ, &ws);
        }
    }

    void spawnCommand(const std::vector<std::string>& cmd) {
        if (running_) return;
        if (cmd.empty()) return;

        // Create PTY
        struct winsize ws = {
            .ws_row = static_cast<unsigned short>(rows_),
            .ws_col = static_cast<unsigned short>(cols_),
        };

        childPid_ = forkpty(&ptyMaster_, nullptr, nullptr, &ws);

        if (childPid_ < 0) {
            return;
        }

        if (childPid_ == 0) {
            // Child process
            std::vector<char*> argv;
            for (const auto& arg : cmd) {
                argv.push_back(const_cast<char*>(arg.c_str()));
            }
            argv.push_back(nullptr);

            execvp(argv[0], argv.data());
            _exit(127);
        }

        // Parent - start reader thread
        running_ = true;
        readerThread_ = std::thread([this]() { readerLoop(); });
    }

    void sendSignal(int sig) {
        if (childPid_ > 0) {
            ::kill(childPid_, sig);
        }
    }

    void readerLoop() {
        char buf[4096];
        struct pollfd pfd = { ptyMaster_, POLLIN, 0 };

        while (running_) {
            int ret = poll(&pfd, 1, 100);  // 100ms timeout

            if (ret > 0 && (pfd.revents & POLLIN)) {
                ssize_t n = read(ptyMaster_, buf, sizeof(buf));
                if (n > 0) {
                    std::lock_guard<std::mutex> lock(vtermMutex_);
                    vterm_input_write(vterm_, buf, n);
                } else if (n <= 0) {
                    break;
                }
            }

            // Check if child exited
            int status;
            pid_t result = waitpid(childPid_, &status, WNOHANG);
            if (result == childPid_) {
                if (WIFEXITED(status)) {
                    exitCode_ = WEXITSTATUS(status);
                } else if (WIFSIGNALED(status)) {
                    exitCode_ = 128 + WTERMSIG(status);
                }
                emitExited(exitCode_);
                break;
            }
        }

        running_ = false;
        close(ptyMaster_);
        ptyMaster_ = -1;
    }
};

int main(int argc, char* argv[]) {
    std::string busName = "org.claude.VTerm";
    int rows = 24, cols = 80;
    std::vector<std::string> cmd;

    // Parse args
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg == "--name" && i + 1 < argc) {
            busName = argv[++i];
        } else if (arg == "--rows" && i + 1 < argc) {
            rows = std::stoi(argv[++i]);
        } else if (arg == "--cols" && i + 1 < argc) {
            cols = std::stoi(argv[++i]);
        } else if (arg == "--") {
            // Everything after -- is the command
            for (int j = i + 1; j < argc; j++) {
                cmd.push_back(argv[j]);
            }
            break;
        }
    }

    auto conn = sdbus::createSessionBusConnection(busName);
    VTermService service(*conn, busName, rows, cols, cmd);

    std::cerr << "vterm-service started: " << busName
              << " (" << rows << "x" << cols << ")";
    if (!cmd.empty()) {
        std::cerr << " running: " << cmd[0];
    }
    std::cerr << std::endl;

    conn->enterEventLoop();

    return 0;
}
</file>

<file path=".gitignore">
.direnv
# Python
__pycache__/
*.pyc

# Nix
result

# Test artifacts
test
*.o
.env
</file>

<file path="flake.lock">
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "lastModified": 1764667669,
        "narHash": "sha256-7WUCZfmqLAssbDqwg9cUDAXrSoXN79eEEq17qhTNM/Y=",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "418468ac9527e799809c900eda37cbff999199b6",
        "type": "github"
      },
      "original": {
        "owner": "NixOS",
        "ref": "nixos-unstable",
        "repo": "nixpkgs",
        "type": "github"
      }
    },
    "root": {
      "inputs": {
        "nixpkgs": "nixpkgs",
        "tagflow": "tagflow"
      }
    },
    "tagflow": {
      "flake": false,
      "locked": {
        "lastModified": 1762754357,
        "narHash": "sha256-CLeLDoh2cxPkqt4rircCUUxemdgskWJYBdPBd7X07Bo=",
        "owner": "lessrest",
        "repo": "tagflow",
        "rev": "cf84326fb41037db8efcefd09898b7659931e77e",
        "type": "github"
      },
      "original": {
        "owner": "lessrest",
        "repo": "tagflow",
        "type": "github"
      }
    }
  },
  "root": "root",
  "version": 7
}
</file>

<file path="flake.nix">
{
  description = "swash - Interactive process sessions over D-Bus";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    tagflow = {
      url = "github:lessrest/tagflow";
      flake = false;
    };
  };

  outputs = { self, nixpkgs, tagflow }:
    let
      system = "x86_64-linux";
      pkgs = nixpkgs.legacyPackages.${system};

      tagflowPkg = pkgs.python3Packages.buildPythonPackage {
        pname = "tagflow";
        version = "0.13.0";
        src = tagflow;
        format = "pyproject";
        nativeBuildInputs = [ pkgs.python3Packages.hatchling ];
        dependencies = with pkgs.python3Packages; [
          anyio
          beautifulsoup4
        ];
        doCheck = false;
      };

      python = pkgs.python3.withPackages (ps: [ ps.sdbus ps.rich ps.mcp ps.anyio ps.systemd-python ps.anthropic ]);

      webPython = pkgs.python3.withPackages (ps: [
        ps.uvicorn
        ps.sdbus
        ps.rich
        ps.anyio
        ps.mcp
        ps.systemd-python
        tagflowPkg
      ]);

      swash = pkgs.writeShellApplication {
        name = "swash";
        runtimeInputs = [ python pkgs.lldb ];
        text = ''
          export PYTHONPATH="${./.}:''${PYTHONPATH:-}"
          exec python3 ${./swash.py} "$@"
        '';
      };

      swashWeb = pkgs.writeShellApplication {
        name = "swash-web";
        runtimeInputs = [ webPython ];
        text = ''
          export PYTHONPATH="${./.}:''${PYTHONPATH:-}"
          exec python3 ${./swash-web.py} "$@"
        '';
      };

      claude = pkgs.writers.writePython3Bin "claude" {
        libraries = with pkgs.python3Packages; [ anthropic rich systemd-python pygit2 rdflib ];
      } (builtins.readFile ./claude.py);
    in
    {
      packages.${system} = {
        inherit swash swashWeb claude;
        default = swash;
      };

      apps.${system} = {
        default = {
          type = "app";
          program = "${swash}/bin/swash";
        };
        web = {
          type = "app";
          program = "${swashWeb}/bin/swash-web";
        };
        claude = {
          type = "app";
          program = "${claude}/bin/claude";
        };
      };

      devShells.${system}.default = pkgs.mkShell {
        packages = [
          (pkgs.python3.withPackages (ps: [ ps.pip ps.virtualenv ]))
          pkgs.lldb
          pkgs.pkg-config
          pkgs.systemd.dev
          pkgs.libgit2
        ];

        shellHook = ''
          if [ ! -d .venv ]; then
            echo "Creating .venv..."
            python -m venv .venv
            .venv/bin/pip install -q anthropic rich sdbus mcp anyio systemd-python uvicorn pygit2 rdflib
          fi
          source .venv/bin/activate
          export PYTHONPATH="${./.}:''${PYTHONPATH:-}"
        '';
      };
    };
}
</file>

</files>
