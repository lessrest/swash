<!DOCTYPE html>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>swa.sh</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    font-size: 16px;
    line-height: 24px;
    margin: 0;
    padding: 0.5rem 0.5rem;
  }

  kbd {
    font: inherit;
  }

  input {
    margin: 0;
  }

  p {
    display: flex;
    align-items: baseline;
    margin: 0.25rem 0;
  }

  audio {
    height: 2rem;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1rem;
    margin: 0;
    padding: 0 0.5rem 0 0;
  }

  button.stop::before {
    content: "‚èπÔ∏è";
  }

  button.play::before {
    content: "‚ñ∂Ô∏è";
  }

  button.record::before {
    content: "‚è∫Ô∏è";
  }

  button.play {
    opacity: 0.5;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #111;
      color: ivory;
    }

    button {
      color: inherit;
    }
  }
</style>
<script>
  const apiUrl =
    document.location.origin.replace(/^http/, "ws") + "/transcribe"

  function tag(tagName, attributes = {}, children = []) {
    const [name, ...classes] = tagName.split(".")
    const element = document.createElement(name)
    if (classes.length) element.classList.add(...classes)
    Object.entries(attributes).forEach(([attr, value]) => {
      if (attr.startsWith("on") && typeof value === "function") {
        const eventName = attr.slice(2).toLowerCase()
        element.addEventListener(eventName, value)
      } else {
        element.setAttribute(attr, value)
      }
    })
    children
      .filter((child) => child !== null && child !== undefined)
      .forEach((child) => {
        if (Array.isArray(child)) {
          child.forEach((c) => {
            element.appendChild(
              c instanceof Node ? c : document.createTextNode(c.toString()),
            )
          })
        } else {
          element.appendChild(
            child instanceof Node
              ? child
              : document.createTextNode(child.toString()),
          )
        }
      })

    return element
  }

  class IndexedDBEventStore {
    constructor(dbName = "swash", storeName = "events") {
      this.dbName = dbName
      this.storeName = storeName
      this.db = null
    }

    async open() {
      if (this.db) {
        return
      }

      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, 1)

        request.onerror = () => {
          reject(new Error("Failed to open IndexedDB"))
        }

        request.onsuccess = (event) => {
          this.db = event.target.result
          resolve()
        }

        request.onupgradeneeded = (event) => {
          const db = event.target.result
          db.createObjectStore(this.storeName, { keyPath: "sequenceNumber" })
        }
      })
    }

    async add(payload) {
      const transaction = this.db.transaction([this.storeName], "readwrite")
      const objectStore = transaction.objectStore(this.storeName)
      const cursorRequest = objectStore.openCursor(null, "prev")

      return new Promise((resolve, reject) => {
        cursorRequest.onerror = reject
        cursorRequest.onsuccess = ({ target: { result: cursor } }) => {
          const event = {
            sequenceNumber: cursor ? cursor.value.sequenceNumber + 1 : 1,
            timestamp: Date.now(),
            payload,
          }

          const addRequest = objectStore.add(event)
          addRequest.onsuccess = () => resolve(event)
          addRequest.onerror = reject
        }
      })
    }

    async getAllEvents() {
      await this.open()
      const transaction = this.db.transaction([this.storeName], "readonly")
      const request = transaction.objectStore(this.storeName).getAll()
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result)
        request.onerror = () => reject(new Error("Failed to get all events"))
      })
    }
  }

  let eventStore = new IndexedDBEventStore()
  let mediaRecorder = null
  let socket = null
  let silenceTimeout = null
  let stream = null

  const dial = () =>
    new Promise((ok, no) => {
      socket = new WebSocket(apiUrl)

      socket.onopen = () => ok(socket)
      socket.onerror = (error) => no(error)
      socket.onmessage = (event) => {
        const message = JSON.parse(event.data)
        eventStore.add({ type: "DeepgramMessage", message })
        handleDeepgramMessage(message)
      }
    })

  document.addEventListener("DOMContentLoaded", async () => {
    micToggle.addEventListener("click", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop()
        micToggle.className = "record"
      } else {
        start()
        micToggle.className = "stop"
      }
    })

    appendParagraph()

    for (const event of await eventStore.getAllEvents()) {
      if (event.payload.type === "DeepgramMessage") {
        handleDeepgramMessage(event.payload.message)
      } else if (event.payload.type === "AudioBlob") {
        addAudioElement(event.payload.blob)
      }
    }
  })

  async function start() {
    stream = await navigator.mediaDevices.getUserMedia({
      audio: true,
    })

    await startRecording()
  }

  async function startRecording() {
    await dial()

    mediaRecorder = new MediaRecorder(stream, {
      audioBitsPerSecond: 128000,
      mimeType: "audio/webm;codecs=opus",
    })

    let chunks = []

    mediaRecorder.ondataavailable = ({ data }) => {
      if (data.size > 0) {
        chunks.push(data)
        socket.send(data)
      }
    }

    mediaRecorder.onstop = () => {
      if (getLastParagraph().textContent.trim() !== "") {
        const blob = new Blob(chunks, { type: "audio/webm;codecs=opus" })
        eventStore.add({ type: "AudioBlob", blob })
        addAudioElement(blob)
      }

      socket.close()
      socket = null
      mediaRecorder = null
      chunks = []
    }

    mediaRecorder.onerror = (error) =>
      console.error("MediaRecorder error:", error)

    mediaRecorder.start(100)

    resetSilence()
  }

  function handleDeepgramMessage(message) {
    if (message.type === "Results") {
      const { words, transcript } = message.channel.alternatives[0]
      const isFinal = message.is_final

      if (transcript.trim() === "") return

      const wordSpans = words.map(({ punctuated_word }) =>
        tag("span.word", {}, [punctuated_word + " "]),
      )

      const span = tag("span", {}, wordSpans)

      const hasInterim = interim.children.length > 0

      if (isFinal) {
        console.log(transcript)
        hasInterim && console.groupEnd()

        interim.replaceChildren()
        getLastParagraph().querySelector(".foo").append(span)
      } else {
        !hasInterim && console.group("‚úèÔ∏è")
        console.log(transcript)

        interim.replaceChildren(span)
      }

      mediaRecorder && resetSilence()
      scrollToBottom()
    }
  }

  function appendParagraph() {
    console.groupEnd()
    console.group("‚ù°")
    return transcript.appendChild(tag("p", {}, [tag("span.foo")]))
  }

  function addAudioElement(blob) {
    const audio = new Audio(URL.createObjectURL(blob))
    const player = tag("button.play", {
      onclick: (e) => {
        e.preventDefault()
        if (audio.paused) {
          audio.play()
          e.target.className = "stop"
        } else {
          audio.stop()
          e.target.className = "play"
        }
      },
    })

    audio.onended = () => {
      player.className = "play"
    }

    const paragraph = getLastParagraph()

    const whisperButton = tag(
      "button",
      {
        onclick: async (e) => {
          e.preventDefault()
          // fetch /whisper with form data file containing the blob
          const formData = new FormData()
          formData.append("file", blob, "audio.webm")

          const response = await fetch("/whisper", {
            method: "POST",
            body: formData,
          })

          if (response.ok) {
            const result = await response.json()
            console.log(result.text)
            paragraph
              .querySelector(".foo")
              .replaceChildren(tag("span.whisper", {}, [result.text]))
          } else {
            console.error("Error calling Whisper API:", response.statusText)
          }
        },
      },
      ["ü™Ñ"],
    )

    paragraph.prepend(player, whisperButton)
    appendParagraph()
    scrollToBottom()
  }

  function getLastParagraph() {
    const p = transcript.querySelector("p:last-of-type")
    return p ? p : appendParagraph()
  }

  function scrollToBottom() {
    getLastParagraph().scrollIntoView({
      behavior: "smooth",
      block: "end",
    })
  }

  function resetSilence() {
    clearTimeout(silenceTimeout)
    silenceTimeout = setTimeout(handleSilence, 3000)
  }

  function handleSilence() {
    if (getLastParagraph().textContent.trim() !== "") {
      mediaRecorder.stop()
      setTimeout(startRecording, 0)
    } else {
      resetSilence()
    }
  }
</script>

<body>
  <article id="transcript"></article>
  <p>
    <button id="micToggle" class="record"></button>
    <kbd id="interim"></kbd>
  </p>
</body>
