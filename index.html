<!DOCTYPE html>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>swa.sh</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    font-size: 16px;
    line-height: 24px;
    margin: 0;
    padding: 0.5rem 0.5rem;
  }

  input {
    margin: 0;
  }

  p {
    margin: 0;
    padding: 0.25rem 0.5rem;
  }

  audio {
    display: block;
    height: 2rem;
    width: 100%;
    margin-bottom: 0.5rem;
  }
</style>
<script>
  const apiUrl =
    document.location.origin.replace(/^http/, "ws") + "/transcribe"

  function tag(tagName, attributes = {}, children = []) {
    const [name, ...classes] = tagName.split(".")
    const element = document.createElement(name)
    if (classes.length) element.classList.add(...classes)
    Object.entries(attributes).forEach(([attr, value]) => {
      if (attr.startsWith("on") && typeof value === "function") {
        const eventName = attr.slice(2).toLowerCase()
        element.addEventListener(eventName, value)
      } else {
        element.setAttribute(attr, value)
      }
    })
    children
      .filter((child) => child !== null && child !== undefined)
      .forEach((child) => {
        if (Array.isArray(child)) {
          child.forEach((c) => {
            element.appendChild(
              c instanceof Node ? c : document.createTextNode(c.toString()),
            )
          })
        } else {
          element.appendChild(
            child instanceof Node
              ? child
              : document.createTextNode(child.toString()),
          )
        }
      })

    return element
  }

  class IndexedDBEventStore {
    constructor(dbName = "swash", storeName = "events") {
      this.dbName = dbName
      this.storeName = storeName
      this.db = null
    }

    async open() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, 1)

        request.onerror = () => {
          reject(new Error("Failed to open IndexedDB"))
        }

        request.onsuccess = (event) => {
          this.db = event.target.result
          resolve()
        }

        request.onupgradeneeded = (event) => {
          const db = event.target.result
          db.createObjectStore(this.storeName, { keyPath: "sequenceNumber" })
        }
      })
    }

    async add(payload) {
      const transaction = this.db.transaction([this.storeName], "readwrite")
      const objectStore = transaction.objectStore(this.storeName)
      const cursorRequest = objectStore.openCursor(null, "prev")

      return new Promise((resolve, reject) => {
        cursorRequest.onerror = reject
        cursorRequest.onsuccess = ({ target: { result: cursor } }) => {
          const event = {
            sequenceNumber: cursor ? cursor.value.sequenceNumber + 1 : 1,
            timestamp: Date.now(),
            payload,
          }

          const addRequest = objectStore.add(event)
          addRequest.onsuccess = () => resolve(event)
          addRequest.onerror = reject
        }
      })
    }

    async getAllEvents() {
      const transaction = this.db.transaction([this.storeName], "readonly")
      const request = transaction.objectStore(this.storeName).getAll()
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result)
        request.onerror = () => reject(new Error("Failed to get all events"))
      })
    }
  }

  let eventStore = new IndexedDBEventStore()
  let mediaRecorder = null
  let socket = null
  let transcriptionTimeout = null
  let stream = null

  function initializeWebSocket() {
    if (socket) {
      socket.close()
    }

    return new Promise((ok, no) => {
      socket = new WebSocket(apiUrl)

      socket.onopen = () => {
        console.log("WebSocket connection established")
        ok(socket)
      }

      socket.onerror = (error) => {
        console.error("WebSocket error:", error)
        no(error)
      }

      socket.onmessage = (event) => {
        const message = JSON.parse(event.data)
        eventStore.add({ type: "DeepgramMessage", message })
        handleDeepgramMessage(message)
      }
    })
  }

  function initialize() {
    micToggle.addEventListener("change", () => {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        pause()
      } else {
        start()
      }
    })

    eventStore
      .open()
      .then(() => {
        eventStore.getAllEvents().then((events) => {
          console.log("Loaded events from IndexedDB:", events)
          for (const event of events) {
            if (event.payload.type === "DeepgramMessage") {
              handleDeepgramMessage(event.payload.message)
            } else if (event.payload.type === "AudioBlob") {
              appendAudioElement(event.payload.blob)
            }
          }
        })
      })
      .catch((error) => {
        console.error("Failed to open IndexedDB event store:", error)
        alert("Failed to open IndexedDB event store")
      })
  }

  async function start() {
    micToggle.disabled = true

    stream = await getUserMedia()
    await startRecording()

    micToggle.checked = true
    micToggle.disabled = false
  }

  function pause() {
    mediaRecorder.pause()
    micToggle.checked = false
    clearTimeout(transcriptionTimeout)
  }

  async function startRecording() {
    if (mediaRecorder) {
      mediaRecorder.stop()
    }

    await initializeWebSocket()

    mediaRecorder = new MediaRecorder(stream, {
      audioBitsPerSecond: 128000,
      mimeType: "audio/webm;codecs=opus",
    })

    const chunks = []

    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        socket.send(event.data)
        chunks.push(event.data)
      }
    }

    mediaRecorder.onstop = () => {
      const paragraph = getLastParagraph()
      if (paragraph.textContent.trim() !== "") {
        const blob = new Blob(chunks, { type: "audio/webm;codecs=opus" })
        eventStore.add({ type: "AudioBlob", blob })
        appendAudioElement(blob)
      }

      chunks.length = 0
      mediaRecorder = null
      socket.close()
      socket = null
    }

    mediaRecorder.onerror = (error) =>
      console.error("MediaRecorder error:", error)

    mediaRecorder.start(100)
    micToggle.textContent = "Pause"
    resetTranscriptionTimeout()
  }

  function handleDeepgramMessage(message) {
    try {
      console.log(message)
      if (message.type === "Results") {
        const alternative = message.channel.alternatives[0]
        const { words } = alternative
        const isFinal = message.is_final

        if (alternative.transcript.trim() === "") {
          return
        }

        resetTranscriptionTimeout()

        let paragraph = getLastParagraph()
        if (!paragraph) {
          paragraph = appendParagraph()
        }

        let interim = paragraph.querySelector("span.interim")
        if (!interim) {
          interim = tag("span.interim", {}, [])
          paragraph.appendChild(interim)
        }

        interim.textContent = ""

        for (const { punctuated_word } of words) {
          interim.appendChild(tag("span.word", {}, [punctuated_word + " "]))
        }

        if (isFinal) {
          interim.className = "final"
        }

        scrollToBottom()
      }
    } catch (error) {
      console.error("Error parsing server message:", error)
    }
  }

  function appendParagraph() {
    const paragraph = tag("p", {}, [])
    document.body.appendChild(paragraph)
    return paragraph
  }

  function appendAudioElement(blob) {
    const audioUrl = URL.createObjectURL(blob)
    const audio = new Audio(audioUrl)
    audio.controls = true
    getLastParagraph().prepend(audio)
    appendParagraph()
    scrollToBottom()
  }

  function getLastParagraph() {
    return document.querySelector("p:last-of-type")
  }

  function scrollToBottom() {
    getLastParagraph().scrollIntoView({
      behavior: "smooth",
      block: "end",
    })
  }

  async function getUserMedia() {
    try {
      return await navigator.mediaDevices.getUserMedia({
        audio: true,
      })
    } catch (error) {
      console.error("getUserMedia error:", error)
    }
  }

  function resetTranscriptionTimeout() {
    if (!mediaRecorder) {
      return
    }

    clearTimeout(transcriptionTimeout)
    transcriptionTimeout = setTimeout(() => {
      if (getLastParagraph().textContent.trim() !== "") {
        console.log("Silence detected, flushing media recorder")
        mediaRecorder.stop()
        setTimeout(startRecording, 0)
      } else {
        console.log("Silence detected, but no audio recorded")
        resetTranscriptionTimeout()
      }
    }, 3000)
  }

  document.addEventListener("DOMContentLoaded", initialize)
</script>
<body>
  <input type="checkbox" id="micToggle" />
</body>
