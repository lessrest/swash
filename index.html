<!DOCTYPE html>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>swa.sh</title>
<style>
  body {
    font-family: system-ui, sans-serif;
    font-size: 16px;
    line-height: 24px;
    margin: 0;
    padding: 0.5rem 0.5rem;
  }

  article {
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  kbd {
    font: inherit;
  }

  input {
    margin: 0;
  }

  p {
    display: flex;
    align-items: baseline;
    margin: 0.25rem 0 0 0;
    width: 56ch;
  }

  audio {
    height: 2rem;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1rem;
    margin: 0;
    padding: 0 0.5rem 0 0;
  }

  button.stop::before {
    content: "‚èπÔ∏è";
  }

  button.play::before {
    content: "‚ñ∂Ô∏è";
  }

  button.record::before {
    content: "‚è∫Ô∏è";
  }

  p:not(:hover) button:not(.record) {
    opacity: 0;
  }

  .whisper {
    font-family: "Big Caslon", "Book Antiqua", "Palatino Linotype", Georgia,
      serif;
  }

  time {
    color: #666;
    /* font-family: "Berkeley Mono", monospace; */
    font-size: 0.85rem;
    line-height: 1rem;
    margin-right: 0.5rem;
    /* letter-spacing: -0.07em; */
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #111;
      color: ivory;
    }

    button {
      color: inherit;
    }
  }
</style>
<script type="module">
  import * as idb from "https://cdn.skypack.dev/idb"

  import { render } from "https://esm.sh/preact@10.7.2"
  import {
    useContext,
    useState,
    useCallback,
    useRef,
    useEffect,
  } from "https://esm.sh/preact@10.7.2/hooks"
  import { html } from "https://esm.sh/htm@3.0.4/preact"

  const apiUrl =
    document.location.origin.replace(/^http/, "ws") + "/transcribe"

  class IndexedDBEventStore {
    constructor(dbName = "swa.sh", storeName = "events") {
      this.dbName = dbName
      this.storeName = storeName
      this.db = null
    }

    async open() {
      if (this.db) {
        return
      }

      this.db = await idb.openDB(this.dbName, 2, {
        upgrade: (db) => {
          db.createObjectStore(this.storeName, { keyPath: "sequenceNumber" })
        },
      })
    }

    async add(payload) {
      await this.open()
      const tx = this.db.transaction(this.storeName, "readwrite")
      const store = tx.objectStore(this.storeName)
      const cursor = await store.openCursor(null, "prev")

      const event = {
        sequenceNumber: cursor ? cursor.value.sequenceNumber + 1 : 1,
        timestamp: Date.now(),
        payload,
      }

      await store.add(event)
      await tx.done
      return event
    }

    async getAllEvents() {
      await this.open()
      return this.db.getAll(this.storeName)
    }
  }

  let eventStore = new IndexedDBEventStore()
  let mediaRecorder = null
  let socket = null
  let silenceTimeout = null
  let stream = null

  const dial = () =>
    new Promise((ok, no) => {
      socket = new WebSocket(apiUrl)

      socket.onopen = () => ok(socket)
      socket.onerror = (error) => no(error)
      socket.onmessage = (event) => {
        const message = JSON.parse(event.data)
        emit({ type: "DeepgramMessage", message })
      }
    })

  function reducer(state, { payload, timestamp }) {
    if (payload.type === "DeepgramMessage") {
      if (payload.message.type !== "Results") return state
      const { words, transcript } = payload.message.channel.alternatives[0]
      const isFinal = payload.message.is_final

      if (transcript.trim() === "") return state

      const timeOfLastWord = Date.now()

      if (isFinal) {
        return {
          ...state,
          current: {
            words: [...state.current.words, ...words],
            timestamp,
          },
          interim: [],
          timeOfLastWord,
        }
      } else {
        return {
          ...state,
          interim: words,
          timeOfLastWord,
        }
      }
    } else if (payload.type === "AudioBlob") {
      return {
        ...state,
        transcript: [
          ...state.transcript,
          {
            words: state.current.words,
            audio: URL.createObjectURL(payload.blob),
            t0: state.current.timestamp,
            timestamp,
          },
        ],
        current: { words: [], timestamp: null },
      }
    } else if (payload.type === "StartedRecording") {
      return {
        ...state,
        timeOfLastWord: null,
      }
    } else if (payload.type === "WhisperResult") {
      return {
        ...state,
        transcript: state.transcript.map((entry) =>
          entry.timestamp === payload.timestamp
            ? { ...entry, whisper: payload.result }
            : entry,
        ),
      }
    } else {
      return state
    }
  }

  function Player({ audio }) {
    const [playing, setPlaying] = useState(false)
    const audioRef = useRef(null)

    useEffect(() => {
      audioRef.current = new Audio(audio)
      audioRef.current.onended = () => setPlaying(false)
      return () => audioRef.current.pause()
    }, [audio])

    const play = useCallback(() => {
      audioRef.current.play()
      setPlaying(true)
    }, [])

    const stop = useCallback(() => {
      audioRef.current.pause()
      audioRef.current.currentTime = 0
      setPlaying(false)
    }, [])

    return html`
      <button
        onClick=${playing ? stop : play}
        className=${playing ? "stop" : "play"}
      ></button>
    `
  }

  function Words({ words }) {
    console.log(words)
    return words.map(({ word, confidence }) => {
      return html`<span style="opacity: ${confidence}">${word + " "}</span>`
    })
  }

  function Whisper({ text }) {
    return html`<span class="whisper">${text}</span>`
  }

  function formatDateTimeHuman(date) {
    return date.toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit",
    })
  }

  function Transcript({ transcript, current }) {
    let prevTimestamp = null
    return html`
      <article>
        ${transcript.map(({ words, audio, timestamp, whisper, t0 }) => {
          const delta = prevTimestamp ? timestamp - prevTimestamp : Infinity
          prevTimestamp = timestamp
          const longPause = delta > 60000

          const wordSpans = whisper
            ? html`<${Whisper} text=${whisper.text} />`
            : html`<${Words} words=${words} />`

          return html`
          ${
            longPause
              ? html`<time style="margin-top: 1.25rem"
                  >${formatDateTimeHuman(new Date(t0))}</time
                >`
              : ""
          }
            <p style=${longPause ? "margin-top: .5rem" : ""}>
              <${Player} audio=${audio} />
              <${WhisperButton}
                audio=${audio}
                timestamp=${timestamp}
              />
              <div style="display: flex; flex-direction: row; align-items: baseline">

                <span>${wordSpans}</span>
              </div>
            </p>
          `
        })}
        ${current.words.length > 0 &&
        html`
        <time style="margin-top: 1.25rem"
          >${formatDateTimeHuman(new Date(current.timestamp))}</time
        >
        <p style="margin-top: 0.5rem">
          <button></button>
          <div style="display: flex; flex-direction: row; align-items: baseline">
            <span><${Words} words=${current.words} /></span>
          </div>
        </p>`}
        <${Interim} interim=${state.interim} />
      </article>
    `
  }

  function WhisperButton({ audio, timestamp }) {
    const whisper = useCallback(async () => {
      const formData = new FormData()
      const blob = await fetch(audio).then((response) => response.blob())
      const extension = blob.type === "audio/mp4" ? "mp4" : "webm"
      console.log(extension, blob, blob.type)
      formData.append("file", blob, `audio.${extension}`)

      const response = await fetch("/whisper", {
        method: "POST",
        body: formData,
      })

      if (response.ok) {
        const result = await response.json()
        emit({ type: "WhisperResult", result, timestamp })
      } else {
        console.error("Error calling Whisper API:", response.statusText)
      }
    }, [audio])

    return html` <button onClick=${whisper}>ü™Ñ</button> `
  }

  async function emit(payload) {
    const event = await eventStore.add(payload)
    update(event)
    console.log(event, state)
  }

  async function startRecording() {
    await dial()

    const mimeType = MediaRecorder.isTypeSupported("audio/webm;codecs=opus")
      ? "audio/webm;codecs=opus"
      : "audio/mp4"

    mediaRecorder = new MediaRecorder(stream, {
      audioBitsPerSecond: 128000,
      mimeType,
    })

    let chunks = []

    mediaRecorder.ondataavailable = ({ data }) => {
      if (data.size > 0) {
        chunks.push(data)
        if (socket && socket.readyState === WebSocket.OPEN) {
          socket.send(data)
        }
      }
    }

    mediaRecorder.onstop = () => {
      if (state.current.words.length > 0) {
        const blob = new Blob(chunks, { type: mimeType })
        emit({ type: "AudioBlob", blob })
      }

      socket.close()
      socket = null
      mediaRecorder = null
      chunks = []
    }

    mediaRecorder.onerror = (error) =>
      console.error("MediaRecorder error:", error)

    mediaRecorder.start(100)

    await emit({ type: "StartedRecording" })
  }

  async function start() {
    if (mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop()
    } else {
      stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      await startRecording()
      setInterval(() => {
        if (mediaRecorder.state === "recording") {
          if (
            state.timeOfLastWord &&
            Date.now() - state.timeOfLastWord > 3000
          ) {
            console.log("stop")
            mediaRecorder.stop()
            setTimeout(startRecording, 0)
          }
        }
      }, 1000)
    }
  }

  function Interim({ interim }) {
    return html`<p>
      <button onClick=${start} className="record"></button>
      <kbd>${interim.map(({ word }) => word + " ")}</kbd>
    </p>`
  }

  let state = {
    transcript: [],
    current: { words: [], timestamp: null },
    interim: [],
    timeOfLastWord: null,
  }

  function show(state) {
    render(
      html`
        <${Transcript}
          transcript=${state.transcript}
          current=${state.current}
          interim=${state.interim}
        />
      `,
      document.getElementById("app"),
    )

    // scroll to bottom
    window.scrollTo(0, document.body.scrollHeight)
  }

  function update(event) {
    state = reducer(state, event)
    show(state)
  }

  document.addEventListener("DOMContentLoaded", async () => {
    for (const event of await eventStore.getAllEvents()) {
      state = reducer(state, event)
    }

    console.log(state)

    show(state)
  })
</script>

<body>
  <div id="app"></div>
</body>
